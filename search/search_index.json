{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ChainConsumer","text":"<p>ChainConsumer is a python package designed to do one thing - consume the chains output from Monte Carlo processes like MCMC. ChainConsumer can utilise these chains to produce plots of the posterior surface inferred from the chain distributions, to plot the chains as walks (to check for mixing and convergence), and to output parameter summaries in the form of LaTeX tables. On top of all of this, if you have multiple models (chains), you can load them all in and perform some model comparison using AIC, BIC or DIC metrics.</p>"},{"location":"#older-versions","title":"Older Versions","text":"<p>For those using older versions of ChainConsumer, you can find a copy of the old documentation using the wayback machine.</p> <ul> <li>Link 1</li> <li>Link 2</li> <li>Link 3</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The latest version of ChainConsumer requires at least Python 3.10. If you have a version of <code>ChainConsumer</code> that is older (v0.34.0 or below) you will find this documentation not very useful.</p> <p><code>pip install chainconsumer</code></p>"},{"location":"#basic-example","title":"Basic Example","text":"<p>If you have some samples, analysing them should be straightforward:</p> <pre><code>from chainconsumer import Chain, ChainConsumer, make_sample\n\n\ndf = make_sample()\nc = ChainConsumer()\nc.add_chain(Chain(samples=df, name=\"An Example Contour\"))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"#common-issues","title":"Common Issues","text":"<p>Users on some Linux platforms have reported issues rendering plots using ChainConsumer. The common error states that <code>dvipng: not found</code>, and as per this StackOverflow post, it can be solved by explicitly installing the <code>matplotlib</code> dependency <code>dvipng</code> via <code>sudo apt-get install dvipng</code>.</p> <p>If you are running on HPC or clusters where you can't install things yourself, users may run into issues where LaTeX or other optional dependencies aren't installed. In this case, ensure <code>usetex=False</code> in your <code>PlotConfig</code> (which is the default). If this does not work, also set <code>serif=False</code>, which has helped some uses.</p>"},{"location":"#citing","title":"Citing","text":"<p>You can cite ChainConsumer using the following BibTeX:</p> <pre><code>   @ARTICLE{Hinton2016,\n      author = {{Hinton}, S.~R.},\n       title = \"{ChainConsumer}\",\n     journal = {The Journal of Open Source Software},\n        year = 2016,\n       month = aug,\n      volume = 1,\n         eid = {00045},\n       pages = {00045},\n         doi = {10.21105/joss.00045},\n      adsurl = {http://adsabs.harvard.edu/abs/2016JOSS....1...45H},\n   }\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Users that wish to contribute to this project may do so in a number of ways. Firstly, for any feature requests, bugs or general ideas, please raise an issue via Github.</p> <p>If you wish to contribute code to the project, please simple fork the project on Github and then raise a pull request. Pull requests will be reviewed to determine whether the changes are major or minor in nature, and to ensure all changes are tested.</p> <p>After cloning down the project, run <code>make install</code> to install all dependencies and pre-commit hook.</p>"},{"location":"usage/","title":"Usage","text":"<p>In general, this is the flow:</p> <ol> <li>Get your samples into a pandas dataframe. If you have another format and want to contribute a translation function, that would be amazing.</li> <li>Turn those samples into a <code>Chain</code>. At this point, you can specify a ton of visual and statistical choices.</li> <li>Give those chains to <code>ChainConsumer</code></li> <li>If you know the truth value of the chains, you can call <code>c.add_truth(Truth(...))</code> to add this to your plots. Note you can have as many truth lines as you want, not just one.</li> <li>If you want to change plotting specific options (but not chain specific options), you can <code>set_plot_config(PlotConfig(...))</code> to control things like the number of ticks, font size, etc.</li> <li>Optionally, use the diagnostics available to see if your chains are stable, or do this via using <code>plot_walks</code></li> <li>Make your contours via <code>plot</code>, or your summaries, or your LaTeX tables.</li> </ol>"},{"location":"usage/#statistics","title":"Statistics","text":"<p>When summarising chains, ChainConsumer offers several different methods. The below image shows the upper and lower bounds and central points for the <code>MAX</code>, <code>CUMULATIVE</code>, <code>MEAN</code> and <code>HDI</code> methods respectively, with their associated bounds.</p> <p></p>"},{"location":"usage/#chainconsumer.statistics.SummaryStatistic","title":"chainconsumer.statistics.SummaryStatistic","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/chainconsumer/statistics.py</code> <pre><code>class SummaryStatistic(Enum):\n    MAX = \"max\"\n    \"\"\"The max value summary statistic is the default. The central point is set\n    to your maximum likelihood, and the upper and lower bounds are determined by\n    finding an iso-likelihood surface which encapsulates the required volume.\"\"\"\n\n    MAX_CENTRAL = \"max_central\"\n    \"\"\"As per the MAX method, this has the centre point at the maximum likelihood.\n    However the lower and upper values come from the CDF, like the cumulative method.\"\"\"\n\n    CUMULATIVE = \"cumulative\"\n    \"\"\"The lower, central, and upper bound are determined by finding where on the marginalised\n    sample CDF the points lie. This means the central point is the median.\"\"\"\n\n    MEAN = \"mean\"\n    \"\"\"As per the cumulative method, except the central value is placed in the midpoint between\n    the upper and lower boundary. Not recommended, but was requested.\"\"\"\n\n    HDI = \"hdi\"\n    \"\"\"Use the highest density interval. Finds the narrowest interval covering the requested mass.\"\"\"\n</code></pre>"},{"location":"usage/#chainconsumer.statistics.SummaryStatistic.MAX","title":"MAX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX = 'max'\n</code></pre> <p>The max value summary statistic is the default. The central point is set to your maximum likelihood, and the upper and lower bounds are determined by finding an iso-likelihood surface which encapsulates the required volume.</p>"},{"location":"usage/#chainconsumer.statistics.SummaryStatistic.MAX_CENTRAL","title":"MAX_CENTRAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_CENTRAL = 'max_central'\n</code></pre> <p>As per the MAX method, this has the centre point at the maximum likelihood. However the lower and upper values come from the CDF, like the cumulative method.</p>"},{"location":"usage/#chainconsumer.statistics.SummaryStatistic.CUMULATIVE","title":"CUMULATIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CUMULATIVE = 'cumulative'\n</code></pre> <p>The lower, central, and upper bound are determined by finding where on the marginalised sample CDF the points lie. This means the central point is the median.</p>"},{"location":"usage/#chainconsumer.statistics.SummaryStatistic.MEAN","title":"MEAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MEAN = 'mean'\n</code></pre> <p>As per the cumulative method, except the central value is placed in the midpoint between the upper and lower boundary. Not recommended, but was requested.</p>"},{"location":"usage/#chainconsumer.statistics.SummaryStatistic.HDI","title":"HDI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HDI = 'hdi'\n</code></pre> <p>Use the highest density interval. Finds the narrowest interval covering the requested mass.</p>"},{"location":"usage/#why-all-these-classes-and-not-just-kwargs","title":"Why all these classes and not just kwargs?","text":"<p>Python type hinting for kwargs isn't quite there yet. <code>TypedDict</code> with Python 3.12 is a big step forward, but I know it'll be a while before the scientific community is all on 3.12. The initial version of ChainConsumer, which was Python 2.7 compatible, didn't have type hints at all. It just took tons of kwargs and passed them around, which also caused a huge ton of duplicated docstring and functions. By encapsulating the options into a dataclass, it becomes much easier for anyone, me or someone who wants to contribute to the repo, to simply add to this class.</p> <p>You don't need to remember to update five other functions, and their docstring. I like that. I don't like the extra verbosity, but it's a price I'm willing to pay for more explicit code and better type hinting.</p>"},{"location":"usage/#how-to-do-overrides","title":"How to do overrides","text":"<p>When you make a Chain, you specify its initial properties.</p> <pre><code>c = ChainConsumer()\nchain = Chain(samples=df, name=\"Something\", shade=True, plot_point=True, color=\"red\")\nc.add_chain(c)\n</code></pre> <p>If you then tell <code>ChainConsumer</code> to add an override, this will then replace your original value, for all chains.</p> <pre><code>c.add_override(ChainConfig(shade=False))\n</code></pre> <p>I note that this override does not modify your original chain. When the plotting code requests final chains from <code>ChainConsumer</code>, the initial chains are copied and their attributes updated by the override.</p>"},{"location":"api/chain/","title":"Chain","text":""},{"location":"api/chain/#chainconsumer.Chain","title":"chainconsumer.Chain","text":"<p>               Bases: <code>ChainConfig</code></p> <p>The numerical chain with its configuration.</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>class Chain(ChainConfig):\n    \"\"\"The numerical chain with its configuration.\"\"\"\n\n    samples: pd.DataFrame = Field(\n        default=...,\n        description=\"The chain data as a pandas DataFrame\",\n    )\n    name: ChainName = Field(\n        default=...,\n        description=\"The name of the chain\",\n    )\n\n    weight_column: ColumnName = Field(\n        default=\"weight\",\n        description=\"The name of the weight column, if it exists\",\n    )\n    posterior_column: ColumnName = Field(\n        default=\"log_posterior\",\n        description=\"The name of the log posterior column, if it exists\",\n    )\n    walkers: int = Field(\n        default=1,\n        ge=1,\n        description=\"The number of walkers in the chain\",\n    )\n    grid: bool = Field(\n        default=False,\n        description=\"Whether the chain is a sampled grid or not\",\n    )\n    num_free_params: int | None = Field(\n        default=None,\n        description=\"The number of free parameters in the chain\",\n        ge=0,\n    )\n    num_eff_data_points: float | None = Field(\n        default=None,\n        description=\"The number of effective data points\",\n        ge=0,\n    )\n    power: float = Field(\n        default=1.0,\n        description=\"Raise the posterior surface to this. Useful for inflating or deflating uncertainty for debugging.\",\n    )\n    show_label_in_legend: bool = Field(\n        default=True,\n        description=\"Whether to show the label in the legend\",\n    )\n    histogram_relative_height: float = Field(\n        default=1.0,\n        description=\"The relative height to plot the marginalised histogram. 1.0 will ensure a normalised histogram.\",\n        ge=0.0,\n    )\n\n    @property\n    def data_columns(self) -&gt; list[str]:\n        \"\"\"The columns in the dataframe which are not weights or posteriors.\"\"\"\n        results = []\n        for c in self.samples.columns:\n            if c in {self.weight_column, self.posterior_column}:\n                continue\n            if c.lower() in {\n                \"weight\",\n                \"weights\",\n                \"posterior\",\n                \"posteriors\",\n                \"log_weights\",\n                \"log_posterior\",\n                \"log_posteriors\",\n            }:\n                continue\n            results.append(c)\n        return results\n\n    @property\n    def data_samples(self) -&gt; pd.DataFrame:\n        \"\"\"The subsection of the dataframe with data points (ie excluding weights and posterior)\"\"\"\n        return self.samples[self.data_columns]\n\n    @property\n    def plotting_columns(self) -&gt; list[str]:\n        \"\"\"The columns to be plotted, which are the dataframe columns\n        with the weights, posterior and colour columns removed.\"\"\"\n        cols = self.data_columns\n        if not self.plot_cloud:\n            return cols\n        return [c for c in cols if c != self.color_param]\n\n    @property\n    def skip(self) -&gt; bool:\n        \"\"\"If the chain will be skipped in plotting because it has nothing to plot.\"\"\"\n        return self.samples.empty or not (self.plot_contour or self.plot_cloud or self.plot_point)\n\n    @property\n    def max_posterior_row(self) -&gt; pd.Series | None:\n        \"\"\"The row of samples which correspond to the maximum posterior value.\n        None if the posterior is not supplied.\"\"\"\n        if self.posterior_column not in self.samples.columns:\n            logging.warning(\"No posterior column found, cannot find max posterior\")\n            return None\n        argmax = self.samples[self.posterior_column].argmax()\n        return self.samples.loc[argmax]  # type: ignore\n\n    @property\n    def weights(self) -&gt; np.ndarray:\n        \"\"\"The column of weights in the samples.\"\"\"\n        return self.samples[self.weight_column].to_numpy()\n\n    @property\n    def log_posterior(self) -&gt; np.ndarray | None:\n        \"\"\"The column of log posteriors in the samples. None if not set.\"\"\"\n        if self.posterior_column not in self.samples.columns:\n            return None\n        return self.samples[self.posterior_column].to_numpy()\n\n    @property\n    def color_data(self) -&gt; np.ndarray | None:\n        \"\"\"The data from the color column. None if not set.\"\"\"\n        if self.color_param is None:\n            return None\n        return self.samples[self.color_param].to_numpy()\n\n    @property\n    def smooth_value(self) -&gt; int:\n        \"\"\"The smoothing value to use for the histogram. If smooth is set, this is the value.\n        If not, it is 0 for gridded data, and 3 for non-gridded data.\"\"\"\n        if self.smooth is not None:\n            return self.smooth\n        if self.grid:\n            return 0\n        return 3\n\n    @field_validator(\"color\")\n    @classmethod\n    def _validate_color(cls, v: str | np.ndarray | list[float] | None) -&gt; str | None:\n        if v is None:\n            return None\n        return colors.format(v)\n\n    @field_validator(\"samples\")\n    @classmethod\n    def _copy_df(cls, v: pd.DataFrame) -&gt; pd.DataFrame:\n        return v.copy()\n\n    @model_validator(mode=\"after\")  # type: ignore\n    def _validate_model(self) -&gt; Chain:\n        assert not self.samples.empty, \"Your chain is empty. This is not ideal.\"\n\n        # If weights aren't set, add them all as one\n        if self.weight_column not in self.samples:\n            assert self.weight_column == \"weight\", (\n                f\"weight column has been changed to {self.weight_column}, but its not in the dataframe\"\n            )\n\n            self.samples[self.weight_column] = 1.0\n        else:\n            assert np.all(self.weights &gt; 0), \"Weights must be positive and non-zero\"\n\n        for column in self.samples.columns:\n            assert isinstance(column, str), f\"Column {column} is not a string\"\n            assert np.all(np.isfinite(self.samples[column])), f\"Column {column} has NaN or inf in it\"\n\n        # Apply the mean shift if it is set to true\n        if self.shift_params:\n            for param in self.samples:\n                self.samples[param] -= np.average(self.samples[param], weights=self.weights)  # type: ignore\n\n        # Check the walkers\n        assert self.samples.shape[0] % self.walkers == 0, (\n            f\"Chain {self.name} has {self.samples.shape[0]} steps, \"\n            \"which is not divisible by {self.walkers} walkers. This is not good.\"\n        )\n\n        # And if the color_params are set, ensure they're in the dataframe\n        if self.color_param is not None:\n            assert self.color_param in self.samples.columns, (\n                f\"Chain {self.name} does not have color parameter {self.color_param}\"\n            )\n\n        # more nan checks\n        if self.num_eff_data_points is not None:\n            assert np.isfinite(self.num_eff_data_points), \"num_eff_data_points is not finite\"\n\n        if self.num_free_params is not None:\n            assert np.isfinite(self.num_free_params), \"num_free_params is not finite\"\n\n        if self.statistics is None:\n            if self.multimodal:\n                self.statistics = SummaryStatistic.HDI\n            else:\n                self.statistics = SummaryStatistic.MAX\n\n        if self.multimodal and self.statistics is not SummaryStatistic.HDI:\n            raise ValueError(\n                f\"Chain {self.name} is marked as multimodal but uses {self.statistics.value}; \"\n                \"set statistics=SummaryStatistic.HDI.\"\n            )\n\n        return self\n\n    def get_data(self, column: str) -&gt; pd.Series[float]:\n        \"\"\"Extracts a single columns from the samples dataframe.\"\"\"\n        return self.samples[column]\n\n    @classmethod\n    def from_covariance(\n        cls,\n        mean: np.ndarray | list[float],\n        covariance: np.ndarray | list[list[float]],\n        columns: list[ColumnName],\n        name: ChainName,\n        **kwargs: Any,\n    ) -&gt; Chain:\n        \"\"\"Generate samples as per mean and covariance supplied. Useful for Fisher matrix forecasts.\n\n        Args:\n            mean: The an array of mean values.\n            covariance: The 2D array describing the covariance.\n                Dimensions should agree with the `mean` input.\n            columns: A list of parameter names, one for each column (dimension) in the mean array.\n            name: The name of the chain.\n            kwargs: Any other arguments to pass to the Chain constructor.\n\n        Returns:\n            The generated chain.\n        \"\"\"\n        rng = np.random.default_rng()\n        samples = rng.multivariate_normal(mean, covariance, size=1000000)  # type: ignore\n        df = pd.DataFrame(samples, columns=columns)\n        return cls(samples=df, name=name, **kwargs)  # type: ignore\n\n    def divide(self) -&gt; list[Chain]:\n        \"\"\"Returns a ChainConsumer instance containing all the walks of a given chain\n        as individual chains themselves.\n\n        This method might be useful if, for example, your chain was made using\n        MCMC with 4 walkers. To check the sampling of all 4 walkers agree, you could\n        call this to get a ChainConsumer instance with one chain for ech of the\n        four walks. If you then plot, hopefully all four contours\n        you would see agree.\n\n        Returns:\n            One chain per walker, split evenly\n        \"\"\"\n        assert self.walkers &gt; 1, \"Cannot divide a chain with only one walker\"\n        assert not self.grid, \"Cannot divide a grid chain\"\n\n        splits = np.split(self.samples, self.walkers)\n        chains = []\n        for i, split in enumerate(splits):\n            df = pd.DataFrame(split, columns=self.samples.columns)\n            options = self.model_dump(exclude={\"samples\", \"name\", \"walkers\"})\n            if \"color\" in options:\n                options.pop(\"color\")\n            chain = Chain(samples=df, name=f\"{self.name} Walker {i}\", **options)\n            chains.append(chain)\n\n        return chains\n\n    def get_max_posterior_point(self) -&gt; MaxPosterior | None:\n        \"\"\"Returns the maximum posterior point in the chain. If the posterior\n\n        Returns:\n            MaxPosterior: The maximum posterior point\n        \"\"\"\n        if self.max_posterior_row is None:\n            return None\n        row = self.max_posterior_row.to_dict()\n        log_posterior = row.pop(self.posterior_column)\n        row = {k: v for k, v in row.items() if k in self.plotting_columns}\n        return MaxPosterior(log_posterior=log_posterior, coordinate=row)\n\n    def get_covariance(self, columns: list[str] | None = None) -&gt; Named2DMatrix:\n        \"\"\"Returns the covariance matrix of the chain.\n\n        Args:\n            columns: The columns to use. None means all data columns.\n\n        Returns:\n            Named2DMatrix: The covariance matrix\n        \"\"\"\n        if columns is None:\n            columns = self.data_columns\n        cov = np.cov(self.samples[columns], rowvar=False, aweights=self.weights)\n        return Named2DMatrix(columns=columns, matrix=cov)\n\n    def get_correlation(self, columns: list[str] | None = None) -&gt; Named2DMatrix:\n        \"\"\"Returns the correlation matrix of the chain.\n\n        Args:\n            columns: The columns to use. None means all data columns.\n\n        Returns:\n            Named2DMatrix: The correlation matrix\n        \"\"\"\n        cov = self.get_covariance(columns)\n        diag = np.sqrt(np.diag(cov.matrix))\n        divisor = diag[None, :] * diag[:, None]  # type: ignore\n        correlations = cov.matrix / divisor\n        return Named2DMatrix(columns=cov.columns, matrix=correlations)\n\n    @classmethod\n    def from_emcee(\n        cls,\n        sampler: emcee.EnsembleSampler,\n        columns: list[str],\n        name: str,\n        thin: int = 1,\n        discard: int = 0,\n        **kwargs: Any,\n    ) -&gt; Chain:\n        \"\"\"Constructor from an emcee sampler\n\n        Args:\n            sampler: The emcee sampler\n            columns: The names of the parameters\n            name: The name of the chain\n            thin: The thinning to apply to the chain\n            discard: The number of steps to discard from the start of the chain\n            kwargs: Any other arguments to pass to the Chain constructor.\n\n        Returns:\n            A ChainConsumer Chain made from the emcee samples\n        \"\"\"\n        chain: np.ndarray = sampler.get_chain(flat=True, thin=thin, discard=discard)  # type: ignore\n        df = pd.DataFrame.from_dict({col: val for col, val in zip(columns, chain.T, strict=False)})\n\n        return cls(samples=df, name=name, **kwargs)\n\n    @classmethod\n    def from_numpyro(\n        cls,\n        mcmc: numpyro.infer.MCMC,\n        name: str,\n        var_names: list[str] | None = None,\n        **kwargs: Any,\n    ) -&gt; Chain:\n        \"\"\"Constructor from numpyro samples\n\n        Args:\n            mcmc: The numpyro sampler\n            name: The name of the chain\n            var_names: The names of the parameters to include in the chain. If the entries of var_names start with ~,\n            they are excluded from the variables. If empty, all parameters are included.\n            kwargs: Any other arguments to pass to the Chain constructor.\n\n        Returns:\n            A ChainConsumer Chain made from numpyro samples\n        \"\"\"\n\n        var_names = _filter_var_names(var_names, list(mcmc.get_samples().keys()))\n        df = pd.DataFrame.from_dict(\n            {key: np.ravel(value) for key, value in mcmc.get_samples().items() if key in var_names}\n        )\n        return cls(samples=df, name=name, **kwargs)\n\n    @classmethod\n    def from_arviz(\n        cls,\n        arviz_id: arviz.InferenceData,\n        name: str,\n        var_names: list[str] | None = None,\n        **kwargs: Any,\n    ) -&gt; Chain:\n        \"\"\"Constructor from an arviz InferenceData object\n\n        Args:\n            arviz_id: The arviz inference data\n            name: The name of the chain\n            var_names: The names of the parameters to include in the chain. If the entries of var_names start with ~,\n            they are excluded from the variables. If empty, all parameters are included.\n            kwargs: Any other arguments to pass to the Chain constructor.\n\n        Returns:\n            A ChainConsumer Chain made from the arviz chain\n        \"\"\"\n\n        import arviz as az\n\n        var_names = _filter_var_names(var_names, list(arviz_id.posterior.keys()))  # type: ignore\n        reduced_id = az.extract(arviz_id, var_names=var_names, group=\"posterior\")\n        df = reduced_id.to_dataframe().drop(columns=[\"chain\", \"draw\"], errors=\"ignore\")\n\n        return cls(samples=df, name=name, **kwargs)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.samples","title":"samples  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>samples: DataFrame = Field(\n    default=...,\n    description=\"The chain data as a pandas DataFrame\",\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: ChainName = Field(\n    default=..., description=\"The name of the chain\"\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.weight_column","title":"weight_column  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight_column: ColumnName = Field(\n    default=\"weight\",\n    description=\"The name of the weight column, if it exists\",\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.posterior_column","title":"posterior_column  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>posterior_column: ColumnName = Field(\n    default=\"log_posterior\",\n    description=\"The name of the log posterior column, if it exists\",\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.walkers","title":"walkers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>walkers: int = Field(\n    default=1,\n    ge=1,\n    description=\"The number of walkers in the chain\",\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: bool = Field(\n    default=False,\n    description=\"Whether the chain is a sampled grid or not\",\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.num_free_params","title":"num_free_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>num_free_params: int | None = Field(\n    default=None,\n    description=\"The number of free parameters in the chain\",\n    ge=0,\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.num_eff_data_points","title":"num_eff_data_points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>num_eff_data_points: float | None = Field(\n    default=None,\n    description=\"The number of effective data points\",\n    ge=0,\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.power","title":"power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>power: float = Field(\n    default=1.0,\n    description=\"Raise the posterior surface to this. Useful for inflating or deflating uncertainty for debugging.\",\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.show_label_in_legend","title":"show_label_in_legend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_label_in_legend: bool = Field(\n    default=True,\n    description=\"Whether to show the label in the legend\",\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.histogram_relative_height","title":"histogram_relative_height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>histogram_relative_height: float = Field(\n    default=1.0,\n    description=\"The relative height to plot the marginalised histogram. 1.0 will ensure a normalised histogram.\",\n    ge=0.0,\n)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.data_columns","title":"data_columns  <code>property</code>","text":"<pre><code>data_columns: list[str]\n</code></pre> <p>The columns in the dataframe which are not weights or posteriors.</p>"},{"location":"api/chain/#chainconsumer.Chain.data_samples","title":"data_samples  <code>property</code>","text":"<pre><code>data_samples: DataFrame\n</code></pre> <p>The subsection of the dataframe with data points (ie excluding weights and posterior)</p>"},{"location":"api/chain/#chainconsumer.Chain.plotting_columns","title":"plotting_columns  <code>property</code>","text":"<pre><code>plotting_columns: list[str]\n</code></pre> <p>The columns to be plotted, which are the dataframe columns with the weights, posterior and colour columns removed.</p>"},{"location":"api/chain/#chainconsumer.Chain.skip","title":"skip  <code>property</code>","text":"<pre><code>skip: bool\n</code></pre> <p>If the chain will be skipped in plotting because it has nothing to plot.</p>"},{"location":"api/chain/#chainconsumer.Chain.max_posterior_row","title":"max_posterior_row  <code>property</code>","text":"<pre><code>max_posterior_row: Series | None\n</code></pre> <p>The row of samples which correspond to the maximum posterior value. None if the posterior is not supplied.</p>"},{"location":"api/chain/#chainconsumer.Chain.weights","title":"weights  <code>property</code>","text":"<pre><code>weights: ndarray\n</code></pre> <p>The column of weights in the samples.</p>"},{"location":"api/chain/#chainconsumer.Chain.log_posterior","title":"log_posterior  <code>property</code>","text":"<pre><code>log_posterior: ndarray | None\n</code></pre> <p>The column of log posteriors in the samples. None if not set.</p>"},{"location":"api/chain/#chainconsumer.Chain.color_data","title":"color_data  <code>property</code>","text":"<pre><code>color_data: ndarray | None\n</code></pre> <p>The data from the color column. None if not set.</p>"},{"location":"api/chain/#chainconsumer.Chain.smooth_value","title":"smooth_value  <code>property</code>","text":"<pre><code>smooth_value: int\n</code></pre> <p>The smoothing value to use for the histogram. If smooth is set, this is the value. If not, it is 0 for gridded data, and 3 for non-gridded data.</p>"},{"location":"api/chain/#chainconsumer.Chain.get_data","title":"get_data","text":"<pre><code>get_data(column: str) -&gt; pd.Series[float]\n</code></pre> <p>Extracts a single columns from the samples dataframe.</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>def get_data(self, column: str) -&gt; pd.Series[float]:\n    \"\"\"Extracts a single columns from the samples dataframe.\"\"\"\n    return self.samples[column]\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.from_covariance","title":"from_covariance  <code>classmethod</code>","text":"<pre><code>from_covariance(\n    mean: ndarray | list[float],\n    covariance: ndarray | list[list[float]],\n    columns: list[ColumnName],\n    name: ChainName,\n    **kwargs: Any,\n) -&gt; Chain\n</code></pre> <p>Generate samples as per mean and covariance supplied. Useful for Fisher matrix forecasts.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray | list[float]</code> <p>The an array of mean values.</p> required <code>covariance</code> <code>ndarray | list[list[float]]</code> <p>The 2D array describing the covariance. Dimensions should agree with the <code>mean</code> input.</p> required <code>columns</code> <code>list[ColumnName]</code> <p>A list of parameter names, one for each column (dimension) in the mean array.</p> required <code>name</code> <code>ChainName</code> <p>The name of the chain.</p> required <code>kwargs</code> <code>Any</code> <p>Any other arguments to pass to the Chain constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Chain</code> <p>The generated chain.</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>@classmethod\ndef from_covariance(\n    cls,\n    mean: np.ndarray | list[float],\n    covariance: np.ndarray | list[list[float]],\n    columns: list[ColumnName],\n    name: ChainName,\n    **kwargs: Any,\n) -&gt; Chain:\n    \"\"\"Generate samples as per mean and covariance supplied. Useful for Fisher matrix forecasts.\n\n    Args:\n        mean: The an array of mean values.\n        covariance: The 2D array describing the covariance.\n            Dimensions should agree with the `mean` input.\n        columns: A list of parameter names, one for each column (dimension) in the mean array.\n        name: The name of the chain.\n        kwargs: Any other arguments to pass to the Chain constructor.\n\n    Returns:\n        The generated chain.\n    \"\"\"\n    rng = np.random.default_rng()\n    samples = rng.multivariate_normal(mean, covariance, size=1000000)  # type: ignore\n    df = pd.DataFrame(samples, columns=columns)\n    return cls(samples=df, name=name, **kwargs)  # type: ignore\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.divide","title":"divide","text":"<pre><code>divide() -&gt; list[Chain]\n</code></pre> <p>Returns a ChainConsumer instance containing all the walks of a given chain as individual chains themselves.</p> <p>This method might be useful if, for example, your chain was made using MCMC with 4 walkers. To check the sampling of all 4 walkers agree, you could call this to get a ChainConsumer instance with one chain for ech of the four walks. If you then plot, hopefully all four contours you would see agree.</p> <p>Returns:</p> Type Description <code>list[Chain]</code> <p>One chain per walker, split evenly</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>def divide(self) -&gt; list[Chain]:\n    \"\"\"Returns a ChainConsumer instance containing all the walks of a given chain\n    as individual chains themselves.\n\n    This method might be useful if, for example, your chain was made using\n    MCMC with 4 walkers. To check the sampling of all 4 walkers agree, you could\n    call this to get a ChainConsumer instance with one chain for ech of the\n    four walks. If you then plot, hopefully all four contours\n    you would see agree.\n\n    Returns:\n        One chain per walker, split evenly\n    \"\"\"\n    assert self.walkers &gt; 1, \"Cannot divide a chain with only one walker\"\n    assert not self.grid, \"Cannot divide a grid chain\"\n\n    splits = np.split(self.samples, self.walkers)\n    chains = []\n    for i, split in enumerate(splits):\n        df = pd.DataFrame(split, columns=self.samples.columns)\n        options = self.model_dump(exclude={\"samples\", \"name\", \"walkers\"})\n        if \"color\" in options:\n            options.pop(\"color\")\n        chain = Chain(samples=df, name=f\"{self.name} Walker {i}\", **options)\n        chains.append(chain)\n\n    return chains\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.get_max_posterior_point","title":"get_max_posterior_point","text":"<pre><code>get_max_posterior_point() -&gt; MaxPosterior | None\n</code></pre> <p>Returns the maximum posterior point in the chain. If the posterior</p> <p>Returns:</p> Name Type Description <code>MaxPosterior</code> <code>MaxPosterior | None</code> <p>The maximum posterior point</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>def get_max_posterior_point(self) -&gt; MaxPosterior | None:\n    \"\"\"Returns the maximum posterior point in the chain. If the posterior\n\n    Returns:\n        MaxPosterior: The maximum posterior point\n    \"\"\"\n    if self.max_posterior_row is None:\n        return None\n    row = self.max_posterior_row.to_dict()\n    log_posterior = row.pop(self.posterior_column)\n    row = {k: v for k, v in row.items() if k in self.plotting_columns}\n    return MaxPosterior(log_posterior=log_posterior, coordinate=row)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.get_covariance","title":"get_covariance","text":"<pre><code>get_covariance(\n    columns: list[str] | None = None,\n) -&gt; Named2DMatrix\n</code></pre> <p>Returns the covariance matrix of the chain.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>list[str] | None</code> <p>The columns to use. None means all data columns.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Named2DMatrix</code> <code>Named2DMatrix</code> <p>The covariance matrix</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>def get_covariance(self, columns: list[str] | None = None) -&gt; Named2DMatrix:\n    \"\"\"Returns the covariance matrix of the chain.\n\n    Args:\n        columns: The columns to use. None means all data columns.\n\n    Returns:\n        Named2DMatrix: The covariance matrix\n    \"\"\"\n    if columns is None:\n        columns = self.data_columns\n    cov = np.cov(self.samples[columns], rowvar=False, aweights=self.weights)\n    return Named2DMatrix(columns=columns, matrix=cov)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.get_correlation","title":"get_correlation","text":"<pre><code>get_correlation(\n    columns: list[str] | None = None,\n) -&gt; Named2DMatrix\n</code></pre> <p>Returns the correlation matrix of the chain.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>list[str] | None</code> <p>The columns to use. None means all data columns.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Named2DMatrix</code> <code>Named2DMatrix</code> <p>The correlation matrix</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>def get_correlation(self, columns: list[str] | None = None) -&gt; Named2DMatrix:\n    \"\"\"Returns the correlation matrix of the chain.\n\n    Args:\n        columns: The columns to use. None means all data columns.\n\n    Returns:\n        Named2DMatrix: The correlation matrix\n    \"\"\"\n    cov = self.get_covariance(columns)\n    diag = np.sqrt(np.diag(cov.matrix))\n    divisor = diag[None, :] * diag[:, None]  # type: ignore\n    correlations = cov.matrix / divisor\n    return Named2DMatrix(columns=cov.columns, matrix=correlations)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.from_emcee","title":"from_emcee  <code>classmethod</code>","text":"<pre><code>from_emcee(\n    sampler: EnsembleSampler,\n    columns: list[str],\n    name: str,\n    thin: int = 1,\n    discard: int = 0,\n    **kwargs: Any,\n) -&gt; Chain\n</code></pre> <p>Constructor from an emcee sampler</p> <p>Parameters:</p> Name Type Description Default <code>sampler</code> <code>EnsembleSampler</code> <p>The emcee sampler</p> required <code>columns</code> <code>list[str]</code> <p>The names of the parameters</p> required <code>name</code> <code>str</code> <p>The name of the chain</p> required <code>thin</code> <code>int</code> <p>The thinning to apply to the chain</p> <code>1</code> <code>discard</code> <code>int</code> <p>The number of steps to discard from the start of the chain</p> <code>0</code> <code>kwargs</code> <code>Any</code> <p>Any other arguments to pass to the Chain constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Chain</code> <p>A ChainConsumer Chain made from the emcee samples</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>@classmethod\ndef from_emcee(\n    cls,\n    sampler: emcee.EnsembleSampler,\n    columns: list[str],\n    name: str,\n    thin: int = 1,\n    discard: int = 0,\n    **kwargs: Any,\n) -&gt; Chain:\n    \"\"\"Constructor from an emcee sampler\n\n    Args:\n        sampler: The emcee sampler\n        columns: The names of the parameters\n        name: The name of the chain\n        thin: The thinning to apply to the chain\n        discard: The number of steps to discard from the start of the chain\n        kwargs: Any other arguments to pass to the Chain constructor.\n\n    Returns:\n        A ChainConsumer Chain made from the emcee samples\n    \"\"\"\n    chain: np.ndarray = sampler.get_chain(flat=True, thin=thin, discard=discard)  # type: ignore\n    df = pd.DataFrame.from_dict({col: val for col, val in zip(columns, chain.T, strict=False)})\n\n    return cls(samples=df, name=name, **kwargs)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.from_numpyro","title":"from_numpyro  <code>classmethod</code>","text":"<pre><code>from_numpyro(\n    mcmc: MCMC,\n    name: str,\n    var_names: list[str] | None = None,\n    **kwargs: Any,\n) -&gt; Chain\n</code></pre> <p>Constructor from numpyro samples</p> <p>Parameters:</p> Name Type Description Default <code>mcmc</code> <code>MCMC</code> <p>The numpyro sampler</p> required <code>name</code> <code>str</code> <p>The name of the chain</p> required <code>var_names</code> <code>list[str] | None</code> <p>The names of the parameters to include in the chain. If the entries of var_names start with ~,</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Any other arguments to pass to the Chain constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Chain</code> <p>A ChainConsumer Chain made from numpyro samples</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>@classmethod\ndef from_numpyro(\n    cls,\n    mcmc: numpyro.infer.MCMC,\n    name: str,\n    var_names: list[str] | None = None,\n    **kwargs: Any,\n) -&gt; Chain:\n    \"\"\"Constructor from numpyro samples\n\n    Args:\n        mcmc: The numpyro sampler\n        name: The name of the chain\n        var_names: The names of the parameters to include in the chain. If the entries of var_names start with ~,\n        they are excluded from the variables. If empty, all parameters are included.\n        kwargs: Any other arguments to pass to the Chain constructor.\n\n    Returns:\n        A ChainConsumer Chain made from numpyro samples\n    \"\"\"\n\n    var_names = _filter_var_names(var_names, list(mcmc.get_samples().keys()))\n    df = pd.DataFrame.from_dict(\n        {key: np.ravel(value) for key, value in mcmc.get_samples().items() if key in var_names}\n    )\n    return cls(samples=df, name=name, **kwargs)\n</code></pre>"},{"location":"api/chain/#chainconsumer.Chain.from_arviz","title":"from_arviz  <code>classmethod</code>","text":"<pre><code>from_arviz(\n    arviz_id: InferenceData,\n    name: str,\n    var_names: list[str] | None = None,\n    **kwargs: Any,\n) -&gt; Chain\n</code></pre> <p>Constructor from an arviz InferenceData object</p> <p>Parameters:</p> Name Type Description Default <code>arviz_id</code> <code>InferenceData</code> <p>The arviz inference data</p> required <code>name</code> <code>str</code> <p>The name of the chain</p> required <code>var_names</code> <code>list[str] | None</code> <p>The names of the parameters to include in the chain. If the entries of var_names start with ~,</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Any other arguments to pass to the Chain constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Chain</code> <p>A ChainConsumer Chain made from the arviz chain</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>@classmethod\ndef from_arviz(\n    cls,\n    arviz_id: arviz.InferenceData,\n    name: str,\n    var_names: list[str] | None = None,\n    **kwargs: Any,\n) -&gt; Chain:\n    \"\"\"Constructor from an arviz InferenceData object\n\n    Args:\n        arviz_id: The arviz inference data\n        name: The name of the chain\n        var_names: The names of the parameters to include in the chain. If the entries of var_names start with ~,\n        they are excluded from the variables. If empty, all parameters are included.\n        kwargs: Any other arguments to pass to the Chain constructor.\n\n    Returns:\n        A ChainConsumer Chain made from the arviz chain\n    \"\"\"\n\n    import arviz as az\n\n    var_names = _filter_var_names(var_names, list(arviz_id.posterior.keys()))  # type: ignore\n    reduced_id = az.extract(arviz_id, var_names=var_names, group=\"posterior\")\n    df = reduced_id.to_dataframe().drop(columns=[\"chain\", \"draw\"], errors=\"ignore\")\n\n    return cls(samples=df, name=name, **kwargs)\n</code></pre>"},{"location":"api/chainconfig/","title":"ChainConfig","text":""},{"location":"api/chainconfig/#chainconsumer.ChainConfig","title":"chainconsumer.ChainConfig","text":"<p>               Bases: <code>BetterBase</code></p> <p>The configuration for a chain. This is used to set the default values for plotting chains, and is also used to store the configuration of a chain.</p> <p>Note that some attributes are defaulted to None instead of their type hint. Like color. This indicates that this parameter should be inferred if not explicitly set, and that this inference requires knowledge of the other chains. For example, if you have two chains, you probably want them to be different colors.</p> Source code in <code>src/chainconsumer/chain.py</code> <pre><code>class ChainConfig(BetterBase):\n    \"\"\"The configuration for a chain. This is used to set the default values for\n    plotting chains, and is also used to store the configuration of a chain.\n\n    Note that some attributes are defaulted to None instead of their type hint.\n    Like color. This indicates that this parameter should be inferred if not explicitly\n    set, and that this inference requires knowledge of the other chains. For example,\n    if you have two chains, you probably want them to be different colors.\n    \"\"\"\n\n    statistics: SummaryStatistic | None = Field(default=None, description=\"The summary statistic to use\")\n    summary_area: float = Field(default=0.6827, ge=0, le=1.0, description=\"The area to use for summary statistics\")\n    sigmas: list[float] = Field(default=[0, 1, 2], description=\"The sigmas to use for summary statistics\")\n    color: ColorInput | None = Field(default=None, description=\"The color of the chain\")  # type: ignore\n    linestyle: str = Field(default=\"-\", description=\"The line style of the chain\")\n    linewidth: float = Field(default=1.0, description=\"The line width of the chain\")\n    show_contour_labels: bool = Field(default=False, description=\"Whether to show contour labels\")\n    shade: bool = Field(default=True, description=\"Whether to shade the chain\")\n    shade_alpha: float = Field(default=0.5, description=\"The alpha of the shading\")\n    shade_gradient: float = Field(default=1.0, description=\"The contrast between contour levels\")\n    bar_shade: bool = Field(default=True, description=\"Whether to shade marginalised distributions\")\n    multimodal: bool = Field(default=False, description=\"Mark the chain as multimodal to enable HDI band splitting.\")\n    bins: int | None = Field(default=None, description=\"The number of bins to use for histograms.\")\n    kde: int | float | bool = Field(default=False, description=\"The bandwidth for KDEs\")\n    smooth: int | None = Field(\n        default=None, description=\"The smoothing for histograms. Set to 0 for no smoothing. Defaults to 3.\"\n    )\n    color_param: str | None = Field(default=None, description=\"The parameter (column) to use for coloring\")\n    cmap: str = Field(default=\"viridis\", description=\"The colormap to use for shading cloud points\")\n    num_cloud: int | float = Field(default=10000, description=\"The number of points in the cloud\")\n    plot_cloud: bool = Field(default=False, description=\"Whether to plot the cloud\")\n    plot_contour: bool = Field(default=True, description=\"Whether to plot contours\")\n    plot_point: bool = Field(default=False, description=\"Whether to plot points\")\n    marker_style: str = Field(default=\".\", description=\"The marker style to use\")\n    marker_size: int | float = Field(default=10.0, ge=1, description=\"The marker size to use\")\n    marker_alpha: int | float = Field(default=1.0, description=\"The marker alpha to use\")\n    zorder: int = Field(default=10, description=\"The zorder to use\")\n    shift_params: bool = Field(\n        default=False,\n        description=\"Whether to shift the parameters by subtracting each parameters mean\",\n    )\n\n    @field_validator(\"color\")\n    @classmethod\n    def _convert_color(cls, v: ColorInput | None) -&gt; str | None:\n        if v is None:\n            return None\n        return colors.format(v)\n\n    def _apply_if_not_user_set(self, **kwargs: Any) -&gt; None:\n        for key, value in kwargs.items():\n            if key not in self._user_specified:\n                setattr(self, key, value)\n\n    def _apply(self, **kwargs: Any) -&gt; None:\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.statistics","title":"statistics  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>statistics: SummaryStatistic | None = Field(\n    default=None, description=\"The summary statistic to use\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.summary_area","title":"summary_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary_area: float = Field(\n    default=0.6827,\n    ge=0,\n    le=1.0,\n    description=\"The area to use for summary statistics\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.sigmas","title":"sigmas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sigmas: list[float] = Field(\n    default=[0, 1, 2],\n    description=\"The sigmas to use for summary statistics\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.color","title":"color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>color: ColorInput | None = Field(\n    default=None, description=\"The color of the chain\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.linestyle","title":"linestyle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>linestyle: str = Field(\n    default=\"-\", description=\"The line style of the chain\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.linewidth","title":"linewidth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>linewidth: float = Field(\n    default=1.0, description=\"The line width of the chain\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.show_contour_labels","title":"show_contour_labels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_contour_labels: bool = Field(\n    default=False,\n    description=\"Whether to show contour labels\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.shade","title":"shade  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shade: bool = Field(\n    default=True, description=\"Whether to shade the chain\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.shade_alpha","title":"shade_alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shade_alpha: float = Field(\n    default=0.5, description=\"The alpha of the shading\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.shade_gradient","title":"shade_gradient  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shade_gradient: float = Field(\n    default=1.0,\n    description=\"The contrast between contour levels\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.bar_shade","title":"bar_shade  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bar_shade: bool = Field(\n    default=True,\n    description=\"Whether to shade marginalised distributions\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.multimodal","title":"multimodal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>multimodal: bool = Field(\n    default=False,\n    description=\"Mark the chain as multimodal to enable HDI band splitting.\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.bins","title":"bins  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bins: int | None = Field(\n    default=None,\n    description=\"The number of bins to use for histograms.\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.kde","title":"kde  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kde: int | float | bool = Field(\n    default=False, description=\"The bandwidth for KDEs\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.smooth","title":"smooth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>smooth: int | None = Field(\n    default=None,\n    description=\"The smoothing for histograms. Set to 0 for no smoothing. Defaults to 3.\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.color_param","title":"color_param  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>color_param: str | None = Field(\n    default=None,\n    description=\"The parameter (column) to use for coloring\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.cmap","title":"cmap  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cmap: str = Field(\n    default=\"viridis\",\n    description=\"The colormap to use for shading cloud points\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.num_cloud","title":"num_cloud  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>num_cloud: int | float = Field(\n    default=10000,\n    description=\"The number of points in the cloud\",\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.plot_cloud","title":"plot_cloud  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plot_cloud: bool = Field(\n    default=False, description=\"Whether to plot the cloud\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.plot_contour","title":"plot_contour  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plot_contour: bool = Field(\n    default=True, description=\"Whether to plot contours\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.plot_point","title":"plot_point  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plot_point: bool = Field(\n    default=False, description=\"Whether to plot points\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.marker_style","title":"marker_style  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>marker_style: str = Field(\n    default=\".\", description=\"The marker style to use\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.marker_size","title":"marker_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>marker_size: int | float = Field(\n    default=10.0, ge=1, description=\"The marker size to use\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.marker_alpha","title":"marker_alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>marker_alpha: int | float = Field(\n    default=1.0, description=\"The marker alpha to use\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.zorder","title":"zorder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zorder: int = Field(\n    default=10, description=\"The zorder to use\"\n)\n</code></pre>"},{"location":"api/chainconfig/#chainconsumer.ChainConfig.shift_params","title":"shift_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shift_params: bool = Field(\n    default=False,\n    description=\"Whether to shift the parameters by subtracting each parameters mean\",\n)\n</code></pre>"},{"location":"api/consumer/","title":"ChainConsumer","text":"<p>The ChainConsumer acts as manager and state holder, to which you supply configured pydantic objects to dictate the behaviour of your plots and analyses.</p>"},{"location":"api/consumer/#chainconsumer.ChainConsumer","title":"chainconsumer.ChainConsumer","text":"<p>A class for consuming chains produced by an MCMC sampling algorithm or grid searches.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>class ChainConsumer:\n    \"\"\"A class for consuming chains produced by an MCMC sampling algorithm or grid searches.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._chains: dict[ChainName, Chain] = {}\n        self._truths: list[Truth] = []\n        self._global_chain_override: ChainConfig | None = None\n\n        self.plotter = Plotter(self)\n        \"\"\"Use this to access all the plotting functions\"\"\"\n        self.diagnostic = Diagnostic(self)\n        \"\"\"Use this to access your diagnostics to see if chains have converged.\"\"\"\n        self.comparison = Comparison(self)\n        \"\"\"Use this to compare chains to each other, like ranking the AIC, BIC, and DIC.\"\"\"\n        self.analysis = Analysis(self)\n        \"\"\"Use this to access the analysis functions, like getting summary statistics from your chains.\"\"\"\n\n    @property\n    def _all_columns(self) -&gt; list[str]:\n        \"\"\"All the columns across all chains\"\"\"\n        return list(set([c for chain in self._chains.values() for c in chain.data_columns]))\n\n    def add_truth(self, truth: Truth) -&gt; \"ChainConsumer\":\n        \"\"\"Add a truth to ChainConsumer.\n\n        Args:\n            truth: The truth to add.\n\n        Returns:\n            Itself, to allow chaining calls.\n        \"\"\"\n        self._truths.append(truth)\n        return self\n\n    def add_chain(self, chain: Chain) -&gt; \"ChainConsumer\":\n        \"\"\"Add a chain to ChainConsumer.\n\n        Args:\n            chain: The chain to add.\n\n        Returns:\n            Itself, to allow chaining calls.\n        \"\"\"\n        key = chain.name\n        assert key not in self._chains, f\"Chain with name {key} already exists!\"\n        self._chains[key] = chain\n        return self\n\n    def set_plot_config(self, plot_config: PlotConfig) -&gt; \"ChainConsumer\":\n        \"\"\"Set the plot config for ChainConsumer.\n\n        Args:\n            plot_config: The plot config to use.\n\n        Returns:\n            Itself, to allow chaining calls.\n        \"\"\"\n        self.plotter.set_config(plot_config)\n        return self\n\n    def add_marker(\n        self,\n        location: dict[ColumnName, float],\n        name: str,\n        color: ColorInput | None = None,\n        marker_size: float = 20.0,\n        marker_style: str = \".\",\n        marker_alpha: float = 1.0,\n        **kwargs,\n    ) -&gt; \"ChainConsumer\":\n        r\"\"\"Add a marker to the plot at the given location.\n\n        Args:\n            location: The location of the marker.\n            name: The name of the marker.\n            color: The colour of the marker. Defaults to None.\n            marker_size: The size of the marker. Defaults to 20.0.\n            marker_style: The style of the marker. Defaults to \".\".\n            marker_alpha: The alpha of the marker. Defaults to 1.0.\n            kwargs: Any other properties to pass into the chain.\n\n\n        Returns:\n            Itself, to allow chaining calls.\n        \"\"\"\n\n        samples = pd.DataFrame(location, index=[0])\n        samples[\"weight\"] = 1.0\n        samples[\"log_posterior\"] = 1.0\n        if color is not None:\n            kwargs[\"color\"] = color\n        chain = Chain(\n            samples=samples,\n            name=name,\n            marker_size=marker_size,\n            marker_style=marker_style,\n            marker_alpha=marker_alpha,\n            plot_contour=False,\n            plot_point=True,\n            **kwargs,\n        )\n        return self.add_chain(chain)\n\n    def remove_chain(self, remove: str | Chain) -&gt; \"ChainConsumer\":\n        r\"\"\"Removes a chain from ChainConsumer.\n\n        Args:\n            remove: The name of the chain to remove, or the chain itself.\n\n        Returns:\n            Itself, to allow chaining calls.\n        \"\"\"\n        if isinstance(remove, Chain):\n            remove = remove.name\n\n        assert remove in self._chains, f\"Chain with name {remove} does not exist!\"\n        self._chains.pop(remove)\n        return self\n\n    def set_override(\n        self,\n        override: ChainConfig,\n    ) -&gt; \"ChainConsumer\":\n        \"\"\"Apply a custom override config\n\n        Args:\n            override: The override config. Defaults to None.\n\n        Returns:\n            Itself, to allow chaining calls.\n        \"\"\"\n        self._global_chain_override = override\n        return self\n\n    def _get_final_chains(self) -&gt; dict[ChainName, Chain]:\n        # Copy the original chain list\n        final_chains = {k: v.model_copy() for k, v in self._chains.items()}\n        num_chains = len([x for x in self._chains.values() if x.plot_contour])\n\n        # Note we only have to override things without a default\n        # and things which should change as the number of chains change\n        global_config: dict[str, Any] = {}\n        global_config[\"bar_shade\"] = num_chains &lt; 5\n        global_config[\"sigmas\"] = [0, 1, 2]\n        global_config[\"shade\"] = num_chains &lt; 5\n        global_config[\"shade_alpha\"] = 1.0 / np.sqrt(num_chains)\n\n        color_iter = colors.next_colour()\n\n        for _, chain in final_chains.items():\n            # copy global config into local config\n            local_config = global_config.copy()\n\n            # Reduce shade alpha if we're showing contour labels\n            if chain.show_contour_labels:\n                local_config[\"shade_alpha\"] *= 0.5\n\n            # Check to see if the color is set\n            if chain.color is None:\n                local_config[\"color\"] = next(color_iter)\n\n            chain._apply_if_not_user_set(**local_config)\n\n            # Apply user overrides\n            if self._global_chain_override is not None:\n                chain._apply(**self._global_chain_override.get_user_specified_dump())\n\n        return final_chains\n\n    def get_chain(self, name: str) -&gt; Chain:\n        \"\"\"Get a chain by name.\n\n        Args:\n            name: The name of the chain.\n\n        Returns:\n            The chain.\n        \"\"\"\n        assert name in self._chains, f\"Chain with name {name} does not exist!\"\n        return self._chains[name]\n\n    def get_names(self) -&gt; list[str]:\n        \"\"\"Get the names of all chains.\n\n        Returns:\n        The names of all chains.\"\"\"\n        return list(self._chains.keys())\n</code></pre>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.plotter","title":"plotter  <code>instance-attribute</code>","text":"<pre><code>plotter = Plotter(self)\n</code></pre> <p>Use this to access all the plotting functions</p>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.diagnostic","title":"diagnostic  <code>instance-attribute</code>","text":"<pre><code>diagnostic = Diagnostic(self)\n</code></pre> <p>Use this to access your diagnostics to see if chains have converged.</p>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.comparison","title":"comparison  <code>instance-attribute</code>","text":"<pre><code>comparison = Comparison(self)\n</code></pre> <p>Use this to compare chains to each other, like ranking the AIC, BIC, and DIC.</p>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.analysis","title":"analysis  <code>instance-attribute</code>","text":"<pre><code>analysis = Analysis(self)\n</code></pre> <p>Use this to access the analysis functions, like getting summary statistics from your chains.</p>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.add_truth","title":"add_truth","text":"<pre><code>add_truth(truth: Truth) -&gt; ChainConsumer\n</code></pre> <p>Add a truth to ChainConsumer.</p> <p>Parameters:</p> Name Type Description Default <code>truth</code> <code>Truth</code> <p>The truth to add.</p> required <p>Returns:</p> Type Description <code>ChainConsumer</code> <p>Itself, to allow chaining calls.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>def add_truth(self, truth: Truth) -&gt; \"ChainConsumer\":\n    \"\"\"Add a truth to ChainConsumer.\n\n    Args:\n        truth: The truth to add.\n\n    Returns:\n        Itself, to allow chaining calls.\n    \"\"\"\n    self._truths.append(truth)\n    return self\n</code></pre>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.add_chain","title":"add_chain","text":"<pre><code>add_chain(chain: Chain) -&gt; ChainConsumer\n</code></pre> <p>Add a chain to ChainConsumer.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Chain</code> <p>The chain to add.</p> required <p>Returns:</p> Type Description <code>ChainConsumer</code> <p>Itself, to allow chaining calls.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>def add_chain(self, chain: Chain) -&gt; \"ChainConsumer\":\n    \"\"\"Add a chain to ChainConsumer.\n\n    Args:\n        chain: The chain to add.\n\n    Returns:\n        Itself, to allow chaining calls.\n    \"\"\"\n    key = chain.name\n    assert key not in self._chains, f\"Chain with name {key} already exists!\"\n    self._chains[key] = chain\n    return self\n</code></pre>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.set_plot_config","title":"set_plot_config","text":"<pre><code>set_plot_config(plot_config: PlotConfig) -&gt; ChainConsumer\n</code></pre> <p>Set the plot config for ChainConsumer.</p> <p>Parameters:</p> Name Type Description Default <code>plot_config</code> <code>PlotConfig</code> <p>The plot config to use.</p> required <p>Returns:</p> Type Description <code>ChainConsumer</code> <p>Itself, to allow chaining calls.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>def set_plot_config(self, plot_config: PlotConfig) -&gt; \"ChainConsumer\":\n    \"\"\"Set the plot config for ChainConsumer.\n\n    Args:\n        plot_config: The plot config to use.\n\n    Returns:\n        Itself, to allow chaining calls.\n    \"\"\"\n    self.plotter.set_config(plot_config)\n    return self\n</code></pre>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.add_marker","title":"add_marker","text":"<pre><code>add_marker(\n    location: dict[ColumnName, float],\n    name: str,\n    color: ColorInput | None = None,\n    marker_size: float = 20.0,\n    marker_style: str = \".\",\n    marker_alpha: float = 1.0,\n    **kwargs,\n) -&gt; ChainConsumer\n</code></pre> <p>Add a marker to the plot at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>dict[ColumnName, float]</code> <p>The location of the marker.</p> required <code>name</code> <code>str</code> <p>The name of the marker.</p> required <code>color</code> <code>ColorInput | None</code> <p>The colour of the marker. Defaults to None.</p> <code>None</code> <code>marker_size</code> <code>float</code> <p>The size of the marker. Defaults to 20.0.</p> <code>20.0</code> <code>marker_style</code> <code>str</code> <p>The style of the marker. Defaults to \".\".</p> <code>'.'</code> <code>marker_alpha</code> <code>float</code> <p>The alpha of the marker. Defaults to 1.0.</p> <code>1.0</code> <code>kwargs</code> <p>Any other properties to pass into the chain.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ChainConsumer</code> <p>Itself, to allow chaining calls.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>def add_marker(\n    self,\n    location: dict[ColumnName, float],\n    name: str,\n    color: ColorInput | None = None,\n    marker_size: float = 20.0,\n    marker_style: str = \".\",\n    marker_alpha: float = 1.0,\n    **kwargs,\n) -&gt; \"ChainConsumer\":\n    r\"\"\"Add a marker to the plot at the given location.\n\n    Args:\n        location: The location of the marker.\n        name: The name of the marker.\n        color: The colour of the marker. Defaults to None.\n        marker_size: The size of the marker. Defaults to 20.0.\n        marker_style: The style of the marker. Defaults to \".\".\n        marker_alpha: The alpha of the marker. Defaults to 1.0.\n        kwargs: Any other properties to pass into the chain.\n\n\n    Returns:\n        Itself, to allow chaining calls.\n    \"\"\"\n\n    samples = pd.DataFrame(location, index=[0])\n    samples[\"weight\"] = 1.0\n    samples[\"log_posterior\"] = 1.0\n    if color is not None:\n        kwargs[\"color\"] = color\n    chain = Chain(\n        samples=samples,\n        name=name,\n        marker_size=marker_size,\n        marker_style=marker_style,\n        marker_alpha=marker_alpha,\n        plot_contour=False,\n        plot_point=True,\n        **kwargs,\n    )\n    return self.add_chain(chain)\n</code></pre>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.remove_chain","title":"remove_chain","text":"<pre><code>remove_chain(remove: str | Chain) -&gt; ChainConsumer\n</code></pre> <p>Removes a chain from ChainConsumer.</p> <p>Parameters:</p> Name Type Description Default <code>remove</code> <code>str | Chain</code> <p>The name of the chain to remove, or the chain itself.</p> required <p>Returns:</p> Type Description <code>ChainConsumer</code> <p>Itself, to allow chaining calls.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>def remove_chain(self, remove: str | Chain) -&gt; \"ChainConsumer\":\n    r\"\"\"Removes a chain from ChainConsumer.\n\n    Args:\n        remove: The name of the chain to remove, or the chain itself.\n\n    Returns:\n        Itself, to allow chaining calls.\n    \"\"\"\n    if isinstance(remove, Chain):\n        remove = remove.name\n\n    assert remove in self._chains, f\"Chain with name {remove} does not exist!\"\n    self._chains.pop(remove)\n    return self\n</code></pre>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.set_override","title":"set_override","text":"<pre><code>set_override(override: ChainConfig) -&gt; ChainConsumer\n</code></pre> <p>Apply a custom override config</p> <p>Parameters:</p> Name Type Description Default <code>override</code> <code>ChainConfig</code> <p>The override config. Defaults to None.</p> required <p>Returns:</p> Type Description <code>ChainConsumer</code> <p>Itself, to allow chaining calls.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>def set_override(\n    self,\n    override: ChainConfig,\n) -&gt; \"ChainConsumer\":\n    \"\"\"Apply a custom override config\n\n    Args:\n        override: The override config. Defaults to None.\n\n    Returns:\n        Itself, to allow chaining calls.\n    \"\"\"\n    self._global_chain_override = override\n    return self\n</code></pre>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.get_chain","title":"get_chain","text":"<pre><code>get_chain(name: str) -&gt; Chain\n</code></pre> <p>Get a chain by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the chain.</p> required <p>Returns:</p> Type Description <code>Chain</code> <p>The chain.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>def get_chain(self, name: str) -&gt; Chain:\n    \"\"\"Get a chain by name.\n\n    Args:\n        name: The name of the chain.\n\n    Returns:\n        The chain.\n    \"\"\"\n    assert name in self._chains, f\"Chain with name {name} does not exist!\"\n    return self._chains[name]\n</code></pre>"},{"location":"api/consumer/#chainconsumer.ChainConsumer.get_names","title":"get_names","text":"<pre><code>get_names() -&gt; list[str]\n</code></pre> <p>Get the names of all chains.</p> <p>Returns: The names of all chains.</p> Source code in <code>src/chainconsumer/chainconsumer.py</code> <pre><code>def get_names(self) -&gt; list[str]:\n    \"\"\"Get the names of all chains.\n\n    Returns:\n    The names of all chains.\"\"\"\n    return list(self._chains.keys())\n</code></pre>"},{"location":"api/plotconfig/","title":"PlotConfig","text":""},{"location":"api/plotconfig/#chainconsumer.PlotConfig","title":"chainconsumer.PlotConfig","text":"<p>               Bases: <code>BetterBase</code></p> Source code in <code>src/chainconsumer/plotting/config.py</code> <pre><code>class PlotConfig(BetterBase):\n    labels: dict[ColumnName, str] = Field(default={}, description=\"Labels for parameters\")\n    max_ticks: int = Field(default=5, ge=0, description=\"Maximum number of ticks to use on axes\")\n    plot_hists: bool = Field(default=True, description=\"Whether to plot the 1D histograms\")\n    flip: bool = Field(default=False, description=\"Whether to flip the 1D histograms\")\n    serif: bool | None = Field(\n        default=False, description=\"Whether to use a serif font. None to not override the rc param.\"\n    )\n    usetex: bool | None = Field(\n        default=False, description=\"Whether to use LaTeX for text rendering. None to not override the rc param.\"\n    )\n    diagonal_tick_labels: bool = Field(default=True, description=\"Whether to show tick labels on the diagonal\")\n    label_font_size: int = Field(default=12, ge=0, description=\"Font size for axis labels\")\n    tick_font_size: int = Field(default=10, ge=0, description=\"Font size for axis ticks\")\n    spacing: float | None = Field(default=None, ge=0, description=\"Spacing between subplots\")\n    contour_label_font_size: int = Field(default=10, ge=0, description=\"Font size for contour labels\")\n    show_legend: bool | None = Field(\n        default=None,\n        description=\"Whether to show the legend. None means determine automatically\",\n    )\n    legend_kwargs: dict[str, Any] = Field(default={}, description=\"Kwargs to pass to the legend\")\n    legend_location: tuple[int, int] | None = Field(default=None, description=\"Which subplot to put the legend in\")\n    legend_artists: bool | None = Field(default=None, description=\"Whether to show artists in the legend\")\n    legend_color_text: bool = Field(default=True, description=\"Whether to color the legend text\")\n    watermark: str | None = Field(default=None, description=\"Watermark text to add to the plot\")\n    watermark_text_kwargs: dict[str, Any] = Field(default={}, description=\"Kwargs to pass to the watermark text\")\n    summarise: bool = Field(default=True, description=\"Whether to annotate the plot with summary statistics\")\n    summary_font_size: int = Field(default=12, ge=0, description=\"Font size for parameter summaries\")\n    sigma2d: bool = Field(\n        default=False,\n        description=(\n            \"Whether to use 2D sigmas for summary statistics. Ie in 2D a 1sigma contour\"\n            r\" does *not* encapsulate 68% of the volume, it covers 39.3% of the volume.\"\n        ),\n    )\n    blind: bool | list[str] = Field(default=False, description=\"Whether to blind some parameters\")\n    log_scales: list[ColumnName] = Field(default=[], description=\"Whether to use log scales for some parameters\")\n    extents: dict[ColumnName, tuple[float, float]] = Field(\n        default={}, description=\"Extents for parameters. Any you don't specify are determined automatically\"\n    )\n    dpi: int = Field(default=300, ge=0, description=\"DPI for the figure\")\n\n    @property\n    def legend_kwargs_final(self) -&gt; dict[str, Any]:\n        default = {\n            \"labelspacing\": 0.3,\n            \"loc\": \"upper right\",\n            \"frameon\": False,\n            \"fontsize\": self.label_font_size,\n            \"handlelength\": 1,\n            \"handletextpad\": 0.2,\n            \"borderaxespad\": 0.0,\n        }\n        return default | self.legend_kwargs\n\n    @property\n    def watermark_text_kwargs_final(self) -&gt; dict[str, Any]:\n        default = {\n            \"color\": \"#333333\",\n            \"alpha\": 0.7,\n            \"verticalalignment\": \"center\",\n            \"horizontalalignment\": \"center\",\n            \"weight\": \"bold\",\n        }\n        return default | self.watermark_text_kwargs\n\n    def get_label(self, column: ColumnName) -&gt; str:\n        return self.labels.get(column, column)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.labels","title":"labels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>labels: dict[ColumnName, str] = Field(\n    default={}, description=\"Labels for parameters\"\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.max_ticks","title":"max_ticks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_ticks: int = Field(\n    default=5,\n    ge=0,\n    description=\"Maximum number of ticks to use on axes\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.plot_hists","title":"plot_hists  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plot_hists: bool = Field(\n    default=True,\n    description=\"Whether to plot the 1D histograms\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.flip","title":"flip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flip: bool = Field(\n    default=False,\n    description=\"Whether to flip the 1D histograms\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.serif","title":"serif  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serif: bool | None = Field(\n    default=False,\n    description=\"Whether to use a serif font. None to not override the rc param.\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.usetex","title":"usetex  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>usetex: bool | None = Field(\n    default=False,\n    description=\"Whether to use LaTeX for text rendering. None to not override the rc param.\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.diagonal_tick_labels","title":"diagonal_tick_labels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>diagonal_tick_labels: bool = Field(\n    default=True,\n    description=\"Whether to show tick labels on the diagonal\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.label_font_size","title":"label_font_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label_font_size: int = Field(\n    default=12,\n    ge=0,\n    description=\"Font size for axis labels\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.tick_font_size","title":"tick_font_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tick_font_size: int = Field(\n    default=10, ge=0, description=\"Font size for axis ticks\"\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.spacing","title":"spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spacing: float | None = Field(\n    default=None,\n    ge=0,\n    description=\"Spacing between subplots\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.contour_label_font_size","title":"contour_label_font_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>contour_label_font_size: int = Field(\n    default=10,\n    ge=0,\n    description=\"Font size for contour labels\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.show_legend","title":"show_legend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_legend: bool | None = Field(\n    default=None,\n    description=\"Whether to show the legend. None means determine automatically\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.legend_kwargs","title":"legend_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>legend_kwargs: dict[str, Any] = Field(\n    default={}, description=\"Kwargs to pass to the legend\"\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.legend_location","title":"legend_location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>legend_location: tuple[int, int] | None = Field(\n    default=None,\n    description=\"Which subplot to put the legend in\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.legend_artists","title":"legend_artists  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>legend_artists: bool | None = Field(\n    default=None,\n    description=\"Whether to show artists in the legend\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.legend_color_text","title":"legend_color_text  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>legend_color_text: bool = Field(\n    default=True,\n    description=\"Whether to color the legend text\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.watermark","title":"watermark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>watermark: str | None = Field(\n    default=None,\n    description=\"Watermark text to add to the plot\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.watermark_text_kwargs","title":"watermark_text_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>watermark_text_kwargs: dict[str, Any] = Field(\n    default={},\n    description=\"Kwargs to pass to the watermark text\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.summarise","title":"summarise  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summarise: bool = Field(\n    default=True,\n    description=\"Whether to annotate the plot with summary statistics\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.summary_font_size","title":"summary_font_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary_font_size: int = Field(\n    default=12,\n    ge=0,\n    description=\"Font size for parameter summaries\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.sigma2d","title":"sigma2d  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sigma2d: bool = Field(\n    default=False,\n    description=\"Whether to use 2D sigmas for summary statistics. Ie in 2D a 1sigma contour does *not* encapsulate 68% of the volume, it covers 39.3% of the volume.\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.blind","title":"blind  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blind: bool | list[str] = Field(\n    default=False,\n    description=\"Whether to blind some parameters\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.log_scales","title":"log_scales  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_scales: list[ColumnName] = Field(\n    default=[],\n    description=\"Whether to use log scales for some parameters\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.extents","title":"extents  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extents: dict[ColumnName, tuple[float, float]] = Field(\n    default={},\n    description=\"Extents for parameters. Any you don't specify are determined automatically\",\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.dpi","title":"dpi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dpi: int = Field(\n    default=300, ge=0, description=\"DPI for the figure\"\n)\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.legend_kwargs_final","title":"legend_kwargs_final  <code>property</code>","text":"<pre><code>legend_kwargs_final: dict[str, Any]\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.watermark_text_kwargs_final","title":"watermark_text_kwargs_final  <code>property</code>","text":"<pre><code>watermark_text_kwargs_final: dict[str, Any]\n</code></pre>"},{"location":"api/plotconfig/#chainconsumer.PlotConfig.get_label","title":"get_label","text":"<pre><code>get_label(column: ColumnName) -&gt; str\n</code></pre> Source code in <code>src/chainconsumer/plotting/config.py</code> <pre><code>def get_label(self, column: ColumnName) -&gt; str:\n    return self.labels.get(column, column)\n</code></pre>"},{"location":"api/plotter/","title":"Plotter","text":"<p>Generally accessible via:</p> <pre><code>from chainconsumer import ChainConsumer\n\nc = ChainConsumer()\n...\nc.plotter\n</code></pre> <p>options: members: - plot - set_config - plot_walks - plot_distributions - plot_summary</p>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter","title":"chainconsumer.plotter.Plotter","text":"Source code in <code>src/chainconsumer/plotter.py</code> <pre><code>class Plotter:\n    def __init__(self, parent: ChainConsumer) -&gt; None:\n        self.parent: ChainConsumer = parent\n        self._config: PlotConfig | None = None\n        self._default_config = PlotConfig()\n\n        self.usetex_old = matplotlib.rcParams[\"text.usetex\"]\n        self.serif_old = matplotlib.rcParams[\"font.family\"]\n\n    def set_config(self, config: PlotConfig) -&gt; None:\n        \"\"\"Sets the plot config to the chosen `PlotConfig` model.\n\n        Args:\n            config: The config to use\n\n        \"\"\"\n        self._config = config\n\n    @property\n    def config(self) -&gt; PlotConfig:\n        if self._config is None:\n            return self._default_config\n        return self._config\n\n    def plot(\n        self,\n        chains: list[ChainName | Chain] | None = None,\n        columns: list[ColumnName] | None = None,\n        filename: list[str | Path] | str | Path | None = None,\n        figsize: FigSize | float | int | tuple[float, float] = FigSize.GROW,\n    ) -&gt; Figure:  # pragma: no cover\n        \"\"\"Plot the chain!\n\n        Args:\n            chains:\n                Used to specify which chain to show if more than one chain is loaded in.\n                Can be an integer, specifying the\n                chain index, or a str, specifying the chain name.\n            columns:\n                If set, only creates a plot for those specific parameters (if list). If an\n                integer is given, only plots the fist so many parameters.\n            filename:\n                If set, saves the figure to this location\n            figsize:\n                The figure size to generate. Accepts a regular two tuple of size in inches,\n                or one of several key words. The default value of ``COLUMN`` creates a figure\n                of appropriate size of insertion into an A4 LaTeX document in two-column mode.\n                ``PAGE`` creates a full page width figure. ``GROW`` creates an image that\n                scales with parameters (1.5 inches per parameter). String arguments are not\n                case sensitive. If you pass a float, it will scale the default ``GROW`` by\n                that amount, so ``2.0`` would result in a plot 3 inches per parameter.\n\n        Returns:\n            the matplotlib figure\n\n        \"\"\"\n        base = self._sanitise(\n            chains, columns, self.config.extents, blind=self.config.blind, log_scales=self.config.log_scales\n        )\n\n        show_legend = self.config.show_legend\n        if show_legend is None:\n            show_legend = len(base.chains) &gt; 1\n\n        num_cax = len(set([chain.color_param for chain in base.chains if chain.color_param is not None]))\n        fig_size = FigSize.get_size(figsize, len(base.columns), num_cax &gt; 0)\n        plot_hists = self.config.plot_hists\n        flip = len(base.columns) == 2 and plot_hists and self.config.flip\n        fig, axes, params_x, params_y = self._get_triangle_figure(base, figsize=fig_size)\n\n        axl = axes.ravel().tolist()\n        num_summary_chains = len([c for c in base.chains if c.plot_contour])\n        summarise = self.config.summarise and num_summary_chains == 1\n\n        paths_for_cbar: dict[ColumnName, PathCollection] = {}\n        for i, p1 in enumerate(params_x):\n            for j, p2 in enumerate(params_y):\n                if i &lt; j:\n                    continue\n                ax: Axes = axes[i, j]\n                do_flip = flip and i == len(params_x) - 1\n\n                # Plot the histograms\n                if plot_hists and i == j:\n                    if do_flip:\n                        plot_truths(ax, self.parent._truths, py=p1)\n                    else:\n                        plot_truths(ax, self.parent._truths, px=p1)\n                    max_val = None\n\n                    # Plot each chain\n                    for chain in base.chains:\n                        if not chain.plot_contour or p1 not in chain.samples:\n                            continue\n\n                        do_summary = summarise and p1 not in base.blind\n                        max_hist_val = self._plot_bars(\n                            ax,\n                            p1,\n                            chain,\n                            flip=do_flip,\n                            summary=do_summary,\n                        )\n\n                        if max_val is None or max_hist_val &gt; max_val:\n                            max_val = max_hist_val\n\n                    if max_val is not None:\n                        if do_flip:\n                            ax.set_xlim(0, 1.1 * max_val)\n                        else:\n                            ax.set_ylim(0, 1.1 * max_val)\n\n                else:\n                    paths_for_cbar |= plot_surface(ax, base.chains, p2, p1, self.config)\n                    plot_truths(ax, self.parent._truths, px=p2, py=p1)\n\n        # Create all the colorbars we need\n        if paths_for_cbar:\n            aspect = fig_size[1] / 0.15\n            fraction = 0.85 / fig_size[0]\n            for column, path in paths_for_cbar.items():\n                cbar = fig.colorbar(path, ax=axl, aspect=aspect, pad=0.03, fraction=fraction, drawedges=False)\n                label = self.config.get_label(column)\n                if label == \"weight\":\n                    label = \"Weights\"\n                elif label == \"log_weight\":\n                    label = \"log(Weights)\"\n                elif label == \"posterior\":\n                    label = \"log(Posterior)\"\n                cbar.set_label(label, fontsize=self.config.label_font_size)\n                if cbar.solids is not None:\n                    cbar.solids.set(alpha=1)\n\n        legend_location = self.config.legend_location\n        if legend_location is None:\n            legend_location = (0, -1) if not flip or len(base.columns) &gt; 2 else (-1, 0)\n        legend_outside = legend_location[0] &gt;= legend_location[1]\n\n        if show_legend:\n            ax = axes[legend_location[0], legend_location[1]]\n            legend_kwargs = self.config.legend_kwargs_final.copy()\n            if \"markerfirst\" not in legend_kwargs:\n                legend_kwargs[\"markerfirst\"] = legend_outside or not self.config.legend_artists\n\n            chains_to_show_on_legend = [c for c in base.chains if c.show_label_in_legend]\n            artists = get_artists_from_chains(chains_to_show_on_legend)\n            leg = ax.legend(handles=artists, **legend_kwargs)\n            if self.config.legend_color_text:\n                for text, chain in zip(leg.get_texts(), chains_to_show_on_legend, strict=False):\n                    text.set_fontweight(\"medium\")\n                    text.set_color(colors.format(chain.color))\n        fig.canvas.draw()\n        for ax in axes[-1, :]:\n            offset = ax.get_xaxis().get_offset_text()\n            ax.set_xlabel(\"{} {}\".format(ax.get_xlabel(), f\"[{offset.get_text()}]\" if offset.get_text() else \"\"))\n            offset.set_visible(False)\n        for ax in axes[:, 0]:\n            offset = ax.get_yaxis().get_offset_text()\n            ax.set_ylabel(\"{} {}\".format(ax.get_ylabel(), f\"[{offset.get_text()}]\" if offset.get_text() else \"\"))\n            offset.set_visible(False)\n\n        if self.config.watermark is not None:\n            ax_watermark = axes[-1, 0] if flip and len(base.columns) == 2 else None\n            add_watermark(fig, ax_watermark, fig_size, self.config)\n\n        self._save_fig(fig, filename, dpi=self.config.dpi)\n\n        return fig\n\n    def _save_fig(self, fig: Figure, filename: list[str | Path] | str | Path | None = None, dpi: int = 300) -&gt; None:\n        if filename is not None:\n            if not isinstance(filename, list):\n                filename = [filename]\n            for f in filename:\n                fig.savefig(f, bbox_inches=\"tight\", dpi=dpi, transparent=True, pad_inches=0.05)\n\n    def plot_walks(\n        self,\n        chains: list[ChainName | Chain] | None = None,\n        columns: list[ColumnName] | None = None,\n        filename: list[str | Path] | str | Path | None = None,\n        figsize: float | tuple[float, float] | None = None,\n        convolve: int | None = None,\n        plot_weights: bool = True,\n        plot_posterior: bool = True,\n        log_weight: bool = False,\n    ) -&gt; Figure:  # pragma: no cover\n        \"\"\"Plots the chain walk; the parameter values as a function of step index.\n\n        This plot is more for a sanity or consistency check than for use with final results.\n        Plotting this before plotting with :func:`plot` allows you to quickly see if the\n        chains are well behaved, or if certain parameters are suspect\n        or require a greater burn in period.\n\n        The desired outcome is to see an unchanging distribution along the x-axis of the plot.\n        If there are obvious tails or features in the parameters, you probably want\n        to investigate.\n\n        Args:\n            chains:\n                Used to specify which chain to show if more than one chain is loaded in.\n                Can be an integer, specifying the\n                chain index, or a str, specifying the chain name.\n            columns:\n                If set, only creates a plot for those specific parameters (if list). If an\n                integer is given, only plots the fist so many parameters.\n            filename:\n                If set, saves the figure to this location\n            figsize:\n                Scale horizontal and vertical figure size.\n            col_wrap:\n                How many columns to plot before wrapping.\n            convolve:\n                If set, overplots a smoothed version of the steps using ``convolve`` as\n                the width of the smoothing filter.\n            plot_weights:\n                If true, plots the weight if they are available\n            plot_posterior:\n                If true, plots the log posterior if they are available\n            log_weight:\n                Whether to display weights in log space or not. If None, the value is\n                inferred by the mean weights of the plotted chains.\n\n        Returns:\n            the matplotlib figure created\n\n        \"\"\"\n\n        base = self._sanitise(\n            chains,\n            columns,\n            self.config.extents,\n            blind=self.config.blind,\n            log_scales=self.config.log_scales,\n        )\n\n        n = len(base.columns)\n        extra = 0\n\n        plot_posterior = plot_posterior and any([c.log_posterior is not None for c in base.chains])\n        if plot_weights:\n            extra += 1\n        if plot_posterior:\n            extra += 1\n\n        if figsize is None:\n            fig_size = (8, 0.75 + (n + extra))\n        elif isinstance(figsize, float | int):\n            fig_size = (figsize, figsize)\n        else:\n            fig_size = figsize\n\n        fig, axes = plt.subplots(figsize=fig_size, nrows=n + extra, squeeze=False, sharex=True)\n        max_points = 100000\n        for i, axes_row in enumerate(axes):\n            ax = axes_row[0]\n            if i &gt;= extra:\n                p = base.columns[i - extra]\n                for chain in base.chains:\n                    if p in chain.data_columns:\n                        chain_row = chain.get_data(p)\n                        if len(chain_row) &gt; max_points:\n                            chain_row = chain_row[:: int(len(chain_row) / max_points)]\n                        log = p in base.log_scales\n                        self._plot_walk(\n                            ax,\n                            p,\n                            chain_row,\n                            extents=base.extents.get(p),\n                            convolve=convolve,\n                            color=colors.format(chain.color),\n                            log_scale=log,\n                        )\n                for truth in self.parent._truths:\n                    if p in truth.location:\n                        self._plot_walk_truth(ax, truth, p)\n\n                if p in base.blind:\n                    ax.set_yticks([])\n            else:  # noqa: PLR5501\n                if i == 0 and plot_posterior:\n                    for chain in base.chains:\n                        if chain.log_posterior is not None:\n                            posterior = chain.log_posterior - chain.log_posterior.max()\n                            if len(posterior) &gt; max_points:\n                                posterior = posterior[:: int(len(posterior) / max_points)]\n\n                            self._plot_walk(\n                                ax,\n                                r\"$\\log(P)$\",\n                                posterior,\n                                convolve=convolve,\n                                color=colors.format(chain.color),\n                            )\n                else:\n                    label = r\"$\\log_{10}$Weight\" if log_weight else \"Weight\"\n\n                    for chain in base.chains:\n                        if chain.weights is not None:\n                            weights = chain.weights\n                            if len(weights) &gt; max_points:\n                                weights = weights[:: int(len(weights) / max_points)]\n                            self._plot_walk(\n                                ax,\n                                label,\n                                np.log10(weights) if log_weight else weights,  # type: ignore\n                                convolve=convolve,\n                                color=colors.format(chain.color),\n                            )\n\n        add_watermark(fig, None, fig_size, self.config, size_scale=0.8)\n        self._save_fig(fig, filename, dpi=self.config.dpi)\n\n        return fig\n\n    def plot_distributions(\n        self,\n        chains: list[ChainName | Chain] | None = None,\n        columns: list[ColumnName] | None = None,\n        filename: list[str | Path] | str | Path | None = None,\n        col_wrap: int = 4,\n        figsize: float | tuple[float, float] | None = None,\n    ) -&gt; Figure:  # pragma: no cover\n        \"\"\"Plots the 1D parameter distributions for verification purposes.\n\n        This plot is more for a sanity or consistency check than for use with final results.\n        Plotting this before plotting with :func:`plot` allows you to quickly see if the\n        chains give well behaved distributions, or if certain parameters are suspect\n        or require a greater burn in period.\n\n        Args:\n            chains:\n                Used to specify which chain to show if more than one chain is loaded in.\n                Can be an integer, specifying the\n                chain index, or a str, specifying the chain name.\n            columns:\n                If set, only creates a plot for those specific parameters (if list). If an\n                integer is given, only plots the fist so many parameters.\n            filename:\n                If set, saves the figure to this location\n            figsize:\n                Scale horizontal and vertical figure size.\n            col_wrap:\n                How many columns to plot before wrapping.\n\n        Returns:\n            the matplotlib figure created\n\n        \"\"\"\n        base = self._sanitise(\n            chains,\n            columns,\n            self.config.extents,\n            blind=self.config.blind,\n            log_scales=self.config.log_scales,\n        )\n\n        n = len(base.columns)\n        num_cols = min(n, col_wrap)\n        num_rows = int(np.ceil(1.0 * n / col_wrap))\n\n        if figsize is None:\n            figsize = 1.0\n        if isinstance(figsize, float | int):\n            figsize_float = figsize\n            figsize = (num_cols * 2.5 * figsize, num_rows * 2.5 * figsize)\n        else:\n            figsize_float = 1.0\n\n        summary = self.config.summarise and len(base.chains) == 1\n        hspace = (0.8 if summary else 0.5) / figsize_float\n        fig, axes = plt.subplots(nrows=num_rows, ncols=num_cols, figsize=figsize, squeeze=False)\n        fig.subplots_adjust(left=0.1, right=0.95, top=0.95, bottom=0.1, wspace=0.05, hspace=hspace)\n\n        formatter = ScalarFormatter(useOffset=False)\n        formatter.set_powerlimits((-3, 4))\n\n        for i, ax in enumerate(axes.flatten()):\n            if i &gt;= n:\n                ax.set_axis_off()\n                continue\n            p = base.columns[i]\n\n            ax.set_yticks([])\n            if p in base.log_scales:\n                ax.set_xscale(\"log\")\n            if p in base.blind:\n                ax.set_xticks([])\n            else:\n                if self.config.diagonal_tick_labels:\n                    _ = [label.set_rotation(45) for label in ax.get_xticklabels()]\n                _ = [label.set_fontsize(self.config.tick_font_size) for label in ax.get_xticklabels()]\n\n                if p in base.log_scales:\n                    ax.xaxis.set_major_locator(LogLocator(numticks=self.config.max_ticks))\n                else:\n                    ax.xaxis.set_major_locator(MaxNLocator(self.config.max_ticks, prune=\"lower\"))\n                    ax.xaxis.set_major_formatter(formatter)\n            ax.set_xlim(base.extents.get(p) or self._get_parameter_extents(p, base.chains))\n\n            max_val = -np.inf\n            for chain in base.chains:\n                if not chain.plot_contour:\n                    continue\n                if p in chain.plotting_columns:\n                    param_summary = summary and p not in base.blind\n                    m = self._plot_bars(ax, p, chain, summary=param_summary)\n                    if max_val is None or m &gt; max_val:\n                        max_val = m\n            plot_truths(ax, self.parent._truths, py=p)\n            ax.set_ylim(0, 1.1 * max_val)\n            ax.set_xlabel(p, fontsize=self.config.label_font_size)\n\n        add_watermark(fig, None, figsize, self.config, size_scale=0.8)\n        self._save_fig(fig, filename, dpi=self.config.dpi)\n        return fig\n\n    def plot_summary(\n        self,\n        chains: list[ChainName | Chain] | None = None,\n        columns: list[ColumnName] | None = None,\n        filename: list[str | Path] | str | Path | None = None,\n        figsize: float = 1.0,\n        errorbar: bool = False,\n        extra_parameter_spacing: float = 1.0,\n        vertical_spacing_ratio: float = 1.0,\n    ) -&gt; Figure:  # pragma: no cover\n        \"\"\"Plots parameter summaries\n\n        This plot is more for a sanity or consistency check than for use with final results.\n        Plotting this before plotting with :func:`plot` allows you to quickly see if the\n        chains give well behaved distributions, or if certain parameters are suspect\n        or require a greater burn in period.\n\n        Args:\n            chains:\n                Used to specify which chain to show if more than one chain is loaded in.\n                Can be an integer, specifying the\n                chain index, or a str, specifying the chain name.\n            columns:\n                If set, only creates a plot for those specific parameters (if list). If an\n                integer is given, only plots the fist so many parameters.\n            filename:\n                If set, saves the figure to this location\n            figsize:\n                Scale horizontal and vertical figure size.\n            errorbar:\n                Whether to onle plot an error bar, instead of the marginalised distribution.\n            include_truth_chain:\n                If you specify another chain as the truth chain, determine if it should still\n                be plotted.\n            extra_parameter_spacing:\n                Increase horizontal space for parameter values\n            vertical_spacing_ratio:\n                Increase vertical space for each model\n        Returns:\n            the matplotlib figure created\n\n        \"\"\"\n        wide_extents = not errorbar\n        base = self._sanitise(\n            chains,\n            columns,\n            self.config.extents,\n            blind=self.config.blind,\n            log_scales=self.config.log_scales,\n            wide_extents=wide_extents,\n        )\n\n        # We have a bit of fun to go from chain names to the width of the\n        # subplot used to display said names\n        max_param = self._get_size_of_texts(base.columns)\n        fid_dpi = 65  # Seriously I have no idea what value this should be\n        param_width = extra_parameter_spacing + max(0.5, max_param / fid_dpi)\n        max_model_name = self._get_size_of_texts([chain.name for chain in base.chains])\n        model_width = 0.25 + (max_model_name / fid_dpi)\n        gridspec_kw = {\n            \"width_ratios\": [model_width] + [param_width] * len(base.columns),\n            \"height_ratios\": [1] * len(base.chains),\n        }\n        ncols = 1 + len(base.columns)\n        top_spacing = 0.3\n        bottom_spacing = 0.2\n        row_height = (0.5 if errorbar else 0.8) * vertical_spacing_ratio\n        width = param_width * len(base.columns) + model_width\n        height = top_spacing + bottom_spacing + row_height * len(base.chains)\n        top_ratio = 1 - (top_spacing / height)\n        bottom_ratio = bottom_spacing / height\n\n        fig_size = (width * figsize, height * figsize)\n        fig, axes = plt.subplots(\n            nrows=len(base.chains), ncols=ncols, figsize=fig_size, squeeze=False, gridspec_kw=gridspec_kw\n        )\n        fig.subplots_adjust(left=0.05, right=0.95, top=top_ratio, bottom=bottom_ratio, wspace=0.0, hspace=0.0)\n        label_font_size = self.config.label_font_size\n        legend_color_text = self.config.legend_color_text\n\n        max_vals: dict[ColumnName, float] = {}\n        num_chains = len(base.chains)\n        for i, axes_row in enumerate(axes):\n            chain = base.chains[i]\n            colour = colors.format(chain.color)\n\n            # First one put name of model\n            ax_first = axes_row[0]\n            ax_first.set_axis_off()\n            text_colour = \"k\" if not legend_color_text else colour\n            ax_first.text(\n                0,\n                0.5,\n                chain.name,\n                transform=ax_first.transAxes,\n                fontsize=label_font_size,\n                verticalalignment=\"center\",\n                color=text_colour,\n                weight=\"medium\",\n            )\n            axes_for_summaries = axes_row[1:]\n\n            for ax, p in zip(axes_for_summaries, base.columns, strict=False):\n                # Set up the frames\n                if i &gt; 0:\n                    ax.spines[\"top\"].set_visible(False)\n                if i &lt; (num_chains - 1):\n                    ax.spines[\"bottom\"].set_visible(False)\n                if i &lt; (num_chains - 1) or p in base.blind:\n                    ax.set_xticks([])\n                ax.set_yticks([])\n                ax.set_xlim(base.extents[p])\n                if p in base.log_scales:\n                    ax.set_xscale(\"log\")\n\n                # Put title in\n                if i == 0:\n                    ax.set_title(self.config.get_label(p), fontsize=label_font_size)\n\n                # Add truth values\n                for truth in self.parent._truths:\n                    truth_value = truth.location.get(p)\n                    if truth_value is not None:\n                        ax.axvline(truth_value, **truth._kwargs)\n\n                # Skip if this chain doesn't have the parameter\n                if p not in chain.data_columns:\n                    continue\n\n                # Plot the good stuff\n                if errorbar:\n                    fv = self.parent.analysis.get_parameter_summary(chain, p)\n                    if fv is None or fv.all_none:\n                        continue\n                    if fv.lower is not None and fv.upper is not None:\n                        diff = np.abs(np.diff(fv.array))\n                        ax.errorbar([fv.center], 0, xerr=[[diff[0]], [diff[1]]], fmt=\"o\", color=colour)\n                else:\n                    m = self._plot_bars(ax, p, chain)\n                    if max_vals.get(p) is None or m &gt; max_vals[p]:\n                        max_vals[p] = m\n\n        for axes_row in axes:\n            for ax, p in zip(axes_row, base.columns, strict=False):\n                if not errorbar:\n                    ax.set_ylim(0, 1.1 * max_vals[p])\n\n        add_watermark(fig, None, fig_size, self.config, size_scale=0.8)\n        self._save_fig(fig, filename, dpi=self.config.dpi)\n\n        return fig\n\n    def _get_size_of_texts(self, texts: list[str]) -&gt; float:  # pragma: no cover\n        usetex = self.config.usetex\n        size = self.config.label_font_size\n        widths = [TextPath((0, 0), text, usetex=usetex, size=size).get_extents().width for text in texts]  # type: ignore\n        return max(widths)\n\n    def _sanitise_columns(self, columns: list[ColumnName] | None, chains: list[Chain]) -&gt; list[ColumnName]:\n        if columns is None:\n            res = []  # Doing it without set to preserve order\n            for chain in chains:\n                for column in chain.plotting_columns:\n                    if column not in res:\n                        res.append(column)\n            return res\n        return columns\n\n    def _sanitise_logscale(self, log_scales: list[ColumnName] | None) -&gt; list[ColumnName]:\n        # We could at some point determine if something should be a log scale by analysing\n        # its distribution, but for now assume its all linear\n        if log_scales is None:\n            return []\n        return log_scales\n\n    def _sanitise_blinds(self, blind: bool | list[ColumnName] | None, columns: list[ColumnName]) -&gt; list[ColumnName]:\n        if blind is None or blind is False:\n            return []\n        elif blind is True:\n            return columns\n        return blind\n\n    def _sanitise(\n        self,\n        chains: list[ChainName | Chain] | None,\n        columns: list[ColumnName] | None,\n        extents: dict[str, tuple[float, float]] | None,\n        blind: bool | list[ColumnName] | None = None,\n        log_scales: list[ColumnName] | None = None,\n        wide_extents: bool = True,\n    ) -&gt; PlottingBase:\n        final_chains = self._sanitise_chains(chains)\n        final_columns = self._sanitise_columns(columns, final_chains)\n        extents = self._get_custom_extents(final_columns, final_chains, extents, wide_extents=wide_extents)\n        self.set_rc_params()\n\n        return PlottingBase(\n            chains=final_chains,\n            columns=final_columns,\n            extents=extents,\n            log_scales=self._sanitise_logscale(log_scales),\n            blind=self._sanitise_blinds(blind, final_columns),\n        )\n\n    def set_rc_params(self) -&gt; None:\n        if self.config.usetex is not None:\n            plt.rc(\"text\", usetex=self.config.usetex)\n        if self.config.serif is not None:\n            plt.rc(\"font\", family=(\"serif\" if self.config.serif else \"sans-serif\"))\n\n    def restore_rc_params(self):\n        \"\"\"Restores the matplotlib rc parameters modified by usetex and serif.\n\n        Unfortunately this cannot be automated because you cannot invoke it whilst you have\n        an active figure object or matplotlib will destroy you. So do all your plotting, close\n        the plots, and then you can call this.\n        \"\"\"\n        plt.rc(\"text\", usetex=self.usetex_old)\n        plt.rc(\"font\", family=self.serif_old)\n\n    def _get_custom_extents(\n        self,\n        columns: list[ColumnName],\n        chains: list[Chain],\n        initial_extents: dict[ColumnName, tuple[float, float]] | None,\n        wide_extents: bool = True,\n    ) -&gt; dict[ColumnName, tuple[float, float]]:  # pragma: no cover\n        if initial_extents is None:\n            initial_extents = {}\n        extents = {} | initial_extents\n        for p in columns:\n            if p not in initial_extents:\n                extents[p] = self._get_parameter_extents(p, chains, wide_extents=wide_extents)\n        return extents\n\n    def _get_triangle_figure(\n        self, base: PlottingBase, figsize: tuple[float, float]\n    ) -&gt; tuple[Figure, np.ndarray, list[ColumnName], list[ColumnName]]:\n        n = len(base.columns)\n        if not self.config.plot_hists:\n            n -= 1\n\n        spacing = self.config.spacing\n        if spacing is None:\n            spacing = 1.0 if n &lt; 6 else 0.0\n\n        gridspec_kw = {}\n        if n == 2 and self.config.plot_hists and self.config.flip:\n            gridspec_kw = {\"width_ratios\": [3, 1], \"height_ratios\": [1, 3]}\n\n        fig, axes = plt.subplots(n, n, figsize=figsize, squeeze=False, gridspec_kw=gridspec_kw)\n        min_left_for_axes = min(max(0.85 / figsize[0], 0.1), 0.3)\n        min_bottom_for_axes = min(max(0.85 / figsize[1], 0.1), 0.3)\n        fig.subplots_adjust(\n            left=min_left_for_axes,\n            right=0.95,\n            top=0.9,\n            bottom=min_bottom_for_axes,\n            wspace=0.05 * spacing,\n            hspace=0.05 * spacing,\n        )\n\n        if self.config.plot_hists:\n            params_x = base.columns\n            params_y = base.columns\n        else:\n            params_x = base.columns[1:]\n            params_y = base.columns[:-1]\n        for i, p1 in enumerate(params_x):\n            for j, p2 in enumerate(params_y):\n                ax = axes[i, j]\n                formatter_x = ScalarFormatter(useOffset=True)\n                formatter_x.set_powerlimits((-3, 4))\n                formatter_y = ScalarFormatter(useOffset=True)\n                formatter_y.set_powerlimits((-3, 4))\n\n                display_x_ticks = False\n                display_y_ticks = False\n                if i &lt; j:\n                    ax.set_frame_on(False)\n                    ax.set_xticks([])\n                    ax.set_yticks([])\n                else:\n                    logx = False\n                    logy = False\n                    if p1 == p2:\n                        if p1 in base.log_scales:\n                            if self.config.flip and j == n - 1:\n                                ax.set_yscale(\"log\")\n                                logy = True\n                            else:\n                                ax.set_xscale(\"log\")\n                                logx = True\n                    else:\n                        if p1 in base.log_scales:\n                            ax.set_yscale(\"log\")\n                            logy = True\n                        if p2 in base.log_scales:\n                            ax.set_xscale(\"log\")\n                            logx = True\n                    if i != n - 1 or (self.config.flip and j == n - 1):\n                        ax.set_xticks([])\n                    else:\n                        if p2 in base.blind:\n                            ax.set_xticks([])\n                        else:\n                            display_x_ticks = True\n                        if isinstance(p2, str):\n                            ax.set_xlabel(self.config.get_label(p2), fontsize=self.config.label_font_size)\n                    if j != 0 or (self.config.plot_hists and i == 0):\n                        ax.set_yticks([])\n                    else:\n                        if p1 in base.blind:\n                            ax.set_yticks([])\n                        else:\n                            display_y_ticks = True\n                        if isinstance(p1, str):\n                            ax.set_ylabel(self.config.get_label(p1), fontsize=self.config.label_font_size)\n                    if display_x_ticks:\n                        if self.config.diagonal_tick_labels:\n                            _ = [label.set_rotation(45) for label in ax.get_xticklabels()]\n                        _ = [label.set_fontsize(self.config.tick_font_size) for label in ax.get_xticklabels()]\n                        if not logx:\n                            ax.xaxis.set_major_locator(MaxNLocator(self.config.max_ticks, prune=\"lower\"))\n                            ax.xaxis.set_major_formatter(formatter_x)\n                        else:\n                            ax.xaxis.set_major_locator(LogLocator(numticks=self.config.max_ticks))\n                    else:\n                        ax.set_xticks([])\n                    if display_y_ticks:\n                        if self.config.diagonal_tick_labels:\n                            _ = [label.set_rotation(45) for label in ax.get_yticklabels()]\n                        _ = [label.set_fontsize(self.config.tick_font_size) for label in ax.get_yticklabels()]\n                        if not logy:\n                            ax.yaxis.set_major_locator(MaxNLocator(self.config.max_ticks, prune=\"lower\"))\n                            ax.yaxis.set_major_formatter(formatter_y)\n                        else:\n                            ax.yaxis.set_major_locator(LogLocator(numticks=self.config.max_ticks))\n                    else:\n                        ax.set_yticks([])\n                    if (i != j or not self.config.plot_hists) or (self.config.flip and i == 1):\n                        ax.set_ylim(base.extents[p1])\n                    ax.set_xlim(base.extents[p2])\n\n        return fig, axes, params_x, params_y\n\n    def _get_parameter_extents(\n        self, column: ColumnName, chains: list[Chain], wide_extents: bool = True\n    ) -&gt; tuple[float, float]:\n        min_val, max_val = np.inf, -np.inf\n        for chain in chains:\n            if column not in chain.samples:\n                continue  # pragma: no cover\n\n            data = chain.get_data(column)\n            min_prop, max_prop = np.inf, -np.inf\n            if chain.plot_contour or chain.plot_cloud:\n                if chain.grid:\n                    min_prop = data.min()\n                    max_prop = data.max()\n                else:\n                    min_prop, max_prop = get_extents(data, chain.weights, plot=True, wide_extents=wide_extents)\n\n            else:\n                point = chain.get_max_posterior_point()\n                if point is not None and column in point.coordinate:\n                    min_prop = point.coordinate[column]\n                    max_prop = min_prop\n\n            min_val = min(min_prop, min_val)\n            max_val = max(max_prop, max_val)\n\n        return min_val, max_val\n\n    def _sanitise_chains(\n        self, chains: list[Chain | ChainName] | dict[ChainName, Chain] | None, include_skip: bool = False\n    ) -&gt; list[Chain]:\n        overriden_chains = self.parent._get_final_chains()\n        final_chains = []\n        if isinstance(chains, list):\n            final_chains = [overriden_chains[c if isinstance(c, ChainName) else c.name] for c in chains]\n        elif isinstance(chains, dict):\n            final_chains = [overriden_chains[c.name] for c in chains.values()]\n        else:\n            final_chains = list(overriden_chains.values())\n        return [c for c in final_chains if include_skip or not c.skip]\n\n    def _plot_bars(\n        self,\n        ax: Axes,\n        column: str,\n        chain: Chain,\n        flip: bool = False,\n        summary: bool = False,\n    ) -&gt; float:  # pragma: no cover\n        # Get values from config\n        data = chain.get_data(column)\n        if chain.smooth_value or chain.kde:\n            xs, ys, _ = self.parent.analysis._get_smoothed_histogram(chain, column, pad=True)\n            ys *= chain.histogram_relative_height\n            if flip:\n                ax.plot(ys, xs, color=chain.color, ls=chain.linestyle, lw=chain.linewidth, zorder=chain.zorder)\n            else:\n                ax.plot(xs, ys, color=chain.color, ls=chain.linestyle, lw=chain.linewidth, zorder=chain.zorder)\n        else:\n            if chain.grid:\n                bins = get_grid_bins(data)\n            else:\n                bins, _ = get_smoothed_bins(chain.smooth_value, get_bins(chain), data, chain.weights)\n            hist, edges = np.histogram(data, bins=bins, density=True, weights=chain.weights)\n            if chain.power is not None:\n                hist = hist**chain.power\n            edge_center = 0.5 * (edges[:-1] + edges[1:])\n            xs, ys = edge_center, hist\n            ys *= chain.histogram_relative_height\n            ax.hist(\n                xs,\n                weights=ys,\n                bins=bins,  # type: ignore\n                histtype=\"step\",\n                color=chain.color,  # type: ignore\n                orientation=\"horizontal\" if flip else \"vertical\",\n                ls=chain.linestyle,\n                lw=chain.linewidth,\n                zorder=chain.zorder,\n            )\n        interp_type = \"linear\" if chain.smooth_value else \"nearest\"\n        interpolator = interp1d(xs, ys, kind=interp_type)\n\n        if chain.bar_shade:\n            base_bound = self.parent.analysis.get_parameter_summary(chain, column)\n\n            if base_bound is not None and base_bound.lower is not None and base_bound.upper is not None:\n                if chain.multimodal:\n                    intervals = self.parent.analysis.get_parameter_hdi_intervals(chain, column)\n                    display_bounds = self.parent.analysis.get_parameter_multimodal_bounds(\n                        chain,\n                        column,\n                        intervals,\n                    )\n\n                    # If we get a single interval, fallback to unimodal HDI\n                    if len(intervals) &lt; 2:\n                        intervals = [(base_bound.lower, base_bound.upper)]\n\n                else:\n                    display_bounds = base_bound\n                    intervals = [(display_bounds.lower, display_bounds.upper)]\n                    intervals = [(max(lower, xs.min()), min(upper, xs.max())) for lower, upper in intervals]\n\n                for lower, upper_ in intervals:\n                    x = np.linspace(lower, upper_, 1000)\n\n                    if flip:\n                        ax.fill_betweenx(\n                            x,\n                            np.zeros_like(x),\n                            interpolator(x),\n                            color=chain.color,\n                            alpha=0.2,\n                            zorder=chain.zorder,\n                        )\n\n                    else:\n                        ax.fill_between(\n                            x,\n                            np.zeros_like(x),\n                            interpolator(x),\n                            color=chain.color,\n                            alpha=0.2,\n                            zorder=chain.zorder,\n                        )\n\n                if summary:\n                    label = self.config.get_label(column)\n                    label_text = label.strip(\"$\") if isinstance(column, str) else None\n\n                    title = self.parent.analysis.get_parameter_text(\n                        display_bounds,\n                        wrap=True,\n                        label=label_text,\n                    )\n\n                    if title:\n                        ax.set_title(title, fontsize=self.config.summary_font_size)\n\n        return float(ys.max())\n\n    def _plot_walk(\n        self,\n        ax: Axes,\n        column: ColumnName,\n        data: pd.Series,\n        extents: tuple[float, float] | None = None,\n        convolve: int | None = None,\n        color: str | None = None,\n        log_scale: bool = False,\n    ) -&gt; None:  # pragma: no cover\n        if extents is not None:\n            ax.set_ylim(extents)\n        assert convolve is None or isinstance(convolve, int), \"Convolve must be an integer pixel window width\"\n        x = np.arange(data.size)\n        ax.set_xlim(0, x[-1])\n        ax.set_ylabel(self.config.get_label(column))\n        if color is None:\n            color = \"#0345A1\"\n        ax.scatter(x, data, c=color, s=2, marker=\".\", edgecolors=\"none\", alpha=0.5)\n        max_ticks = self.config.max_ticks\n        if log_scale:\n            ax.set_yscale(\"log\")\n            ax.yaxis.set_major_locator(LogLocator(numticks=max_ticks))\n        else:\n            ax.yaxis.set_major_locator(MaxNLocator(max_ticks, prune=\"lower\"))\n\n        if convolve is not None:\n            trim = int(0.5 * convolve)\n            color2 = colors.scale_colour(color, 0.5)\n            filt = np.ones(convolve) / convolve\n            filtered = np.convolve(data, filt, mode=\"same\")\n            ax.plot(x[trim:-trim], filtered[trim:-trim], color=color2, alpha=1)\n\n    def _plot_walk_truth(self, ax: Axes, truth: Truth, col: str) -&gt; None:\n        ax.axhline(truth.location[col], **truth._kwargs)\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: ChainConsumer = parent\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.usetex_old","title":"usetex_old  <code>instance-attribute</code>","text":"<pre><code>usetex_old = rcParams['text.usetex']\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.serif_old","title":"serif_old  <code>instance-attribute</code>","text":"<pre><code>serif_old = rcParams['font.family']\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.config","title":"config  <code>property</code>","text":"<pre><code>config: PlotConfig\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.set_config","title":"set_config","text":"<pre><code>set_config(config: PlotConfig) -&gt; None\n</code></pre> <p>Sets the plot config to the chosen <code>PlotConfig</code> model.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PlotConfig</code> <p>The config to use</p> required Source code in <code>src/chainconsumer/plotter.py</code> <pre><code>def set_config(self, config: PlotConfig) -&gt; None:\n    \"\"\"Sets the plot config to the chosen `PlotConfig` model.\n\n    Args:\n        config: The config to use\n\n    \"\"\"\n    self._config = config\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.plot","title":"plot","text":"<pre><code>plot(\n    chains: list[ChainName | Chain] | None = None,\n    columns: list[ColumnName] | None = None,\n    filename: list[str | Path] | str | Path | None = None,\n    figsize: FigSize\n    | float\n    | int\n    | tuple[float, float] = FigSize.GROW,\n) -&gt; Figure\n</code></pre> <p>Plot the chain!</p> <p>Parameters:</p> Name Type Description Default <code>chains</code> <code>list[ChainName | Chain] | None</code> <p>Used to specify which chain to show if more than one chain is loaded in. Can be an integer, specifying the chain index, or a str, specifying the chain name.</p> <code>None</code> <code>columns</code> <code>list[ColumnName] | None</code> <p>If set, only creates a plot for those specific parameters (if list). If an integer is given, only plots the fist so many parameters.</p> <code>None</code> <code>filename</code> <code>list[str | Path] | str | Path | None</code> <p>If set, saves the figure to this location</p> <code>None</code> <code>figsize</code> <code>FigSize | float | int | tuple[float, float]</code> <p>The figure size to generate. Accepts a regular two tuple of size in inches, or one of several key words. The default value of <code>COLUMN</code> creates a figure of appropriate size of insertion into an A4 LaTeX document in two-column mode. <code>PAGE</code> creates a full page width figure. <code>GROW</code> creates an image that scales with parameters (1.5 inches per parameter). String arguments are not case sensitive. If you pass a float, it will scale the default <code>GROW</code> by that amount, so <code>2.0</code> would result in a plot 3 inches per parameter.</p> <code>GROW</code> <p>Returns:</p> Type Description <code>Figure</code> <p>the matplotlib figure</p> Source code in <code>src/chainconsumer/plotter.py</code> <pre><code>def plot(\n    self,\n    chains: list[ChainName | Chain] | None = None,\n    columns: list[ColumnName] | None = None,\n    filename: list[str | Path] | str | Path | None = None,\n    figsize: FigSize | float | int | tuple[float, float] = FigSize.GROW,\n) -&gt; Figure:  # pragma: no cover\n    \"\"\"Plot the chain!\n\n    Args:\n        chains:\n            Used to specify which chain to show if more than one chain is loaded in.\n            Can be an integer, specifying the\n            chain index, or a str, specifying the chain name.\n        columns:\n            If set, only creates a plot for those specific parameters (if list). If an\n            integer is given, only plots the fist so many parameters.\n        filename:\n            If set, saves the figure to this location\n        figsize:\n            The figure size to generate. Accepts a regular two tuple of size in inches,\n            or one of several key words. The default value of ``COLUMN`` creates a figure\n            of appropriate size of insertion into an A4 LaTeX document in two-column mode.\n            ``PAGE`` creates a full page width figure. ``GROW`` creates an image that\n            scales with parameters (1.5 inches per parameter). String arguments are not\n            case sensitive. If you pass a float, it will scale the default ``GROW`` by\n            that amount, so ``2.0`` would result in a plot 3 inches per parameter.\n\n    Returns:\n        the matplotlib figure\n\n    \"\"\"\n    base = self._sanitise(\n        chains, columns, self.config.extents, blind=self.config.blind, log_scales=self.config.log_scales\n    )\n\n    show_legend = self.config.show_legend\n    if show_legend is None:\n        show_legend = len(base.chains) &gt; 1\n\n    num_cax = len(set([chain.color_param for chain in base.chains if chain.color_param is not None]))\n    fig_size = FigSize.get_size(figsize, len(base.columns), num_cax &gt; 0)\n    plot_hists = self.config.plot_hists\n    flip = len(base.columns) == 2 and plot_hists and self.config.flip\n    fig, axes, params_x, params_y = self._get_triangle_figure(base, figsize=fig_size)\n\n    axl = axes.ravel().tolist()\n    num_summary_chains = len([c for c in base.chains if c.plot_contour])\n    summarise = self.config.summarise and num_summary_chains == 1\n\n    paths_for_cbar: dict[ColumnName, PathCollection] = {}\n    for i, p1 in enumerate(params_x):\n        for j, p2 in enumerate(params_y):\n            if i &lt; j:\n                continue\n            ax: Axes = axes[i, j]\n            do_flip = flip and i == len(params_x) - 1\n\n            # Plot the histograms\n            if plot_hists and i == j:\n                if do_flip:\n                    plot_truths(ax, self.parent._truths, py=p1)\n                else:\n                    plot_truths(ax, self.parent._truths, px=p1)\n                max_val = None\n\n                # Plot each chain\n                for chain in base.chains:\n                    if not chain.plot_contour or p1 not in chain.samples:\n                        continue\n\n                    do_summary = summarise and p1 not in base.blind\n                    max_hist_val = self._plot_bars(\n                        ax,\n                        p1,\n                        chain,\n                        flip=do_flip,\n                        summary=do_summary,\n                    )\n\n                    if max_val is None or max_hist_val &gt; max_val:\n                        max_val = max_hist_val\n\n                if max_val is not None:\n                    if do_flip:\n                        ax.set_xlim(0, 1.1 * max_val)\n                    else:\n                        ax.set_ylim(0, 1.1 * max_val)\n\n            else:\n                paths_for_cbar |= plot_surface(ax, base.chains, p2, p1, self.config)\n                plot_truths(ax, self.parent._truths, px=p2, py=p1)\n\n    # Create all the colorbars we need\n    if paths_for_cbar:\n        aspect = fig_size[1] / 0.15\n        fraction = 0.85 / fig_size[0]\n        for column, path in paths_for_cbar.items():\n            cbar = fig.colorbar(path, ax=axl, aspect=aspect, pad=0.03, fraction=fraction, drawedges=False)\n            label = self.config.get_label(column)\n            if label == \"weight\":\n                label = \"Weights\"\n            elif label == \"log_weight\":\n                label = \"log(Weights)\"\n            elif label == \"posterior\":\n                label = \"log(Posterior)\"\n            cbar.set_label(label, fontsize=self.config.label_font_size)\n            if cbar.solids is not None:\n                cbar.solids.set(alpha=1)\n\n    legend_location = self.config.legend_location\n    if legend_location is None:\n        legend_location = (0, -1) if not flip or len(base.columns) &gt; 2 else (-1, 0)\n    legend_outside = legend_location[0] &gt;= legend_location[1]\n\n    if show_legend:\n        ax = axes[legend_location[0], legend_location[1]]\n        legend_kwargs = self.config.legend_kwargs_final.copy()\n        if \"markerfirst\" not in legend_kwargs:\n            legend_kwargs[\"markerfirst\"] = legend_outside or not self.config.legend_artists\n\n        chains_to_show_on_legend = [c for c in base.chains if c.show_label_in_legend]\n        artists = get_artists_from_chains(chains_to_show_on_legend)\n        leg = ax.legend(handles=artists, **legend_kwargs)\n        if self.config.legend_color_text:\n            for text, chain in zip(leg.get_texts(), chains_to_show_on_legend, strict=False):\n                text.set_fontweight(\"medium\")\n                text.set_color(colors.format(chain.color))\n    fig.canvas.draw()\n    for ax in axes[-1, :]:\n        offset = ax.get_xaxis().get_offset_text()\n        ax.set_xlabel(\"{} {}\".format(ax.get_xlabel(), f\"[{offset.get_text()}]\" if offset.get_text() else \"\"))\n        offset.set_visible(False)\n    for ax in axes[:, 0]:\n        offset = ax.get_yaxis().get_offset_text()\n        ax.set_ylabel(\"{} {}\".format(ax.get_ylabel(), f\"[{offset.get_text()}]\" if offset.get_text() else \"\"))\n        offset.set_visible(False)\n\n    if self.config.watermark is not None:\n        ax_watermark = axes[-1, 0] if flip and len(base.columns) == 2 else None\n        add_watermark(fig, ax_watermark, fig_size, self.config)\n\n    self._save_fig(fig, filename, dpi=self.config.dpi)\n\n    return fig\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.plot_walks","title":"plot_walks","text":"<pre><code>plot_walks(\n    chains: list[ChainName | Chain] | None = None,\n    columns: list[ColumnName] | None = None,\n    filename: list[str | Path] | str | Path | None = None,\n    figsize: float | tuple[float, float] | None = None,\n    convolve: int | None = None,\n    plot_weights: bool = True,\n    plot_posterior: bool = True,\n    log_weight: bool = False,\n) -&gt; Figure\n</code></pre> <p>Plots the chain walk; the parameter values as a function of step index.</p> <p>This plot is more for a sanity or consistency check than for use with final results. Plotting this before plotting with :func:<code>plot</code> allows you to quickly see if the chains are well behaved, or if certain parameters are suspect or require a greater burn in period.</p> <p>The desired outcome is to see an unchanging distribution along the x-axis of the plot. If there are obvious tails or features in the parameters, you probably want to investigate.</p> <p>Parameters:</p> Name Type Description Default <code>chains</code> <code>list[ChainName | Chain] | None</code> <p>Used to specify which chain to show if more than one chain is loaded in. Can be an integer, specifying the chain index, or a str, specifying the chain name.</p> <code>None</code> <code>columns</code> <code>list[ColumnName] | None</code> <p>If set, only creates a plot for those specific parameters (if list). If an integer is given, only plots the fist so many parameters.</p> <code>None</code> <code>filename</code> <code>list[str | Path] | str | Path | None</code> <p>If set, saves the figure to this location</p> <code>None</code> <code>figsize</code> <code>float | tuple[float, float] | None</code> <p>Scale horizontal and vertical figure size.</p> <code>None</code> <code>col_wrap</code> <p>How many columns to plot before wrapping.</p> required <code>convolve</code> <code>int | None</code> <p>If set, overplots a smoothed version of the steps using <code>convolve</code> as the width of the smoothing filter.</p> <code>None</code> <code>plot_weights</code> <code>bool</code> <p>If true, plots the weight if they are available</p> <code>True</code> <code>plot_posterior</code> <code>bool</code> <p>If true, plots the log posterior if they are available</p> <code>True</code> <code>log_weight</code> <code>bool</code> <p>Whether to display weights in log space or not. If None, the value is inferred by the mean weights of the plotted chains.</p> <code>False</code> <p>Returns:</p> Type Description <code>Figure</code> <p>the matplotlib figure created</p> Source code in <code>src/chainconsumer/plotter.py</code> <pre><code>def plot_walks(\n    self,\n    chains: list[ChainName | Chain] | None = None,\n    columns: list[ColumnName] | None = None,\n    filename: list[str | Path] | str | Path | None = None,\n    figsize: float | tuple[float, float] | None = None,\n    convolve: int | None = None,\n    plot_weights: bool = True,\n    plot_posterior: bool = True,\n    log_weight: bool = False,\n) -&gt; Figure:  # pragma: no cover\n    \"\"\"Plots the chain walk; the parameter values as a function of step index.\n\n    This plot is more for a sanity or consistency check than for use with final results.\n    Plotting this before plotting with :func:`plot` allows you to quickly see if the\n    chains are well behaved, or if certain parameters are suspect\n    or require a greater burn in period.\n\n    The desired outcome is to see an unchanging distribution along the x-axis of the plot.\n    If there are obvious tails or features in the parameters, you probably want\n    to investigate.\n\n    Args:\n        chains:\n            Used to specify which chain to show if more than one chain is loaded in.\n            Can be an integer, specifying the\n            chain index, or a str, specifying the chain name.\n        columns:\n            If set, only creates a plot for those specific parameters (if list). If an\n            integer is given, only plots the fist so many parameters.\n        filename:\n            If set, saves the figure to this location\n        figsize:\n            Scale horizontal and vertical figure size.\n        col_wrap:\n            How many columns to plot before wrapping.\n        convolve:\n            If set, overplots a smoothed version of the steps using ``convolve`` as\n            the width of the smoothing filter.\n        plot_weights:\n            If true, plots the weight if they are available\n        plot_posterior:\n            If true, plots the log posterior if they are available\n        log_weight:\n            Whether to display weights in log space or not. If None, the value is\n            inferred by the mean weights of the plotted chains.\n\n    Returns:\n        the matplotlib figure created\n\n    \"\"\"\n\n    base = self._sanitise(\n        chains,\n        columns,\n        self.config.extents,\n        blind=self.config.blind,\n        log_scales=self.config.log_scales,\n    )\n\n    n = len(base.columns)\n    extra = 0\n\n    plot_posterior = plot_posterior and any([c.log_posterior is not None for c in base.chains])\n    if plot_weights:\n        extra += 1\n    if plot_posterior:\n        extra += 1\n\n    if figsize is None:\n        fig_size = (8, 0.75 + (n + extra))\n    elif isinstance(figsize, float | int):\n        fig_size = (figsize, figsize)\n    else:\n        fig_size = figsize\n\n    fig, axes = plt.subplots(figsize=fig_size, nrows=n + extra, squeeze=False, sharex=True)\n    max_points = 100000\n    for i, axes_row in enumerate(axes):\n        ax = axes_row[0]\n        if i &gt;= extra:\n            p = base.columns[i - extra]\n            for chain in base.chains:\n                if p in chain.data_columns:\n                    chain_row = chain.get_data(p)\n                    if len(chain_row) &gt; max_points:\n                        chain_row = chain_row[:: int(len(chain_row) / max_points)]\n                    log = p in base.log_scales\n                    self._plot_walk(\n                        ax,\n                        p,\n                        chain_row,\n                        extents=base.extents.get(p),\n                        convolve=convolve,\n                        color=colors.format(chain.color),\n                        log_scale=log,\n                    )\n            for truth in self.parent._truths:\n                if p in truth.location:\n                    self._plot_walk_truth(ax, truth, p)\n\n            if p in base.blind:\n                ax.set_yticks([])\n        else:  # noqa: PLR5501\n            if i == 0 and plot_posterior:\n                for chain in base.chains:\n                    if chain.log_posterior is not None:\n                        posterior = chain.log_posterior - chain.log_posterior.max()\n                        if len(posterior) &gt; max_points:\n                            posterior = posterior[:: int(len(posterior) / max_points)]\n\n                        self._plot_walk(\n                            ax,\n                            r\"$\\log(P)$\",\n                            posterior,\n                            convolve=convolve,\n                            color=colors.format(chain.color),\n                        )\n            else:\n                label = r\"$\\log_{10}$Weight\" if log_weight else \"Weight\"\n\n                for chain in base.chains:\n                    if chain.weights is not None:\n                        weights = chain.weights\n                        if len(weights) &gt; max_points:\n                            weights = weights[:: int(len(weights) / max_points)]\n                        self._plot_walk(\n                            ax,\n                            label,\n                            np.log10(weights) if log_weight else weights,  # type: ignore\n                            convolve=convolve,\n                            color=colors.format(chain.color),\n                        )\n\n    add_watermark(fig, None, fig_size, self.config, size_scale=0.8)\n    self._save_fig(fig, filename, dpi=self.config.dpi)\n\n    return fig\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.plot_distributions","title":"plot_distributions","text":"<pre><code>plot_distributions(\n    chains: list[ChainName | Chain] | None = None,\n    columns: list[ColumnName] | None = None,\n    filename: list[str | Path] | str | Path | None = None,\n    col_wrap: int = 4,\n    figsize: float | tuple[float, float] | None = None,\n) -&gt; Figure\n</code></pre> <p>Plots the 1D parameter distributions for verification purposes.</p> <p>This plot is more for a sanity or consistency check than for use with final results. Plotting this before plotting with :func:<code>plot</code> allows you to quickly see if the chains give well behaved distributions, or if certain parameters are suspect or require a greater burn in period.</p> <p>Parameters:</p> Name Type Description Default <code>chains</code> <code>list[ChainName | Chain] | None</code> <p>Used to specify which chain to show if more than one chain is loaded in. Can be an integer, specifying the chain index, or a str, specifying the chain name.</p> <code>None</code> <code>columns</code> <code>list[ColumnName] | None</code> <p>If set, only creates a plot for those specific parameters (if list). If an integer is given, only plots the fist so many parameters.</p> <code>None</code> <code>filename</code> <code>list[str | Path] | str | Path | None</code> <p>If set, saves the figure to this location</p> <code>None</code> <code>figsize</code> <code>float | tuple[float, float] | None</code> <p>Scale horizontal and vertical figure size.</p> <code>None</code> <code>col_wrap</code> <code>int</code> <p>How many columns to plot before wrapping.</p> <code>4</code> <p>Returns:</p> Type Description <code>Figure</code> <p>the matplotlib figure created</p> Source code in <code>src/chainconsumer/plotter.py</code> <pre><code>def plot_distributions(\n    self,\n    chains: list[ChainName | Chain] | None = None,\n    columns: list[ColumnName] | None = None,\n    filename: list[str | Path] | str | Path | None = None,\n    col_wrap: int = 4,\n    figsize: float | tuple[float, float] | None = None,\n) -&gt; Figure:  # pragma: no cover\n    \"\"\"Plots the 1D parameter distributions for verification purposes.\n\n    This plot is more for a sanity or consistency check than for use with final results.\n    Plotting this before plotting with :func:`plot` allows you to quickly see if the\n    chains give well behaved distributions, or if certain parameters are suspect\n    or require a greater burn in period.\n\n    Args:\n        chains:\n            Used to specify which chain to show if more than one chain is loaded in.\n            Can be an integer, specifying the\n            chain index, or a str, specifying the chain name.\n        columns:\n            If set, only creates a plot for those specific parameters (if list). If an\n            integer is given, only plots the fist so many parameters.\n        filename:\n            If set, saves the figure to this location\n        figsize:\n            Scale horizontal and vertical figure size.\n        col_wrap:\n            How many columns to plot before wrapping.\n\n    Returns:\n        the matplotlib figure created\n\n    \"\"\"\n    base = self._sanitise(\n        chains,\n        columns,\n        self.config.extents,\n        blind=self.config.blind,\n        log_scales=self.config.log_scales,\n    )\n\n    n = len(base.columns)\n    num_cols = min(n, col_wrap)\n    num_rows = int(np.ceil(1.0 * n / col_wrap))\n\n    if figsize is None:\n        figsize = 1.0\n    if isinstance(figsize, float | int):\n        figsize_float = figsize\n        figsize = (num_cols * 2.5 * figsize, num_rows * 2.5 * figsize)\n    else:\n        figsize_float = 1.0\n\n    summary = self.config.summarise and len(base.chains) == 1\n    hspace = (0.8 if summary else 0.5) / figsize_float\n    fig, axes = plt.subplots(nrows=num_rows, ncols=num_cols, figsize=figsize, squeeze=False)\n    fig.subplots_adjust(left=0.1, right=0.95, top=0.95, bottom=0.1, wspace=0.05, hspace=hspace)\n\n    formatter = ScalarFormatter(useOffset=False)\n    formatter.set_powerlimits((-3, 4))\n\n    for i, ax in enumerate(axes.flatten()):\n        if i &gt;= n:\n            ax.set_axis_off()\n            continue\n        p = base.columns[i]\n\n        ax.set_yticks([])\n        if p in base.log_scales:\n            ax.set_xscale(\"log\")\n        if p in base.blind:\n            ax.set_xticks([])\n        else:\n            if self.config.diagonal_tick_labels:\n                _ = [label.set_rotation(45) for label in ax.get_xticklabels()]\n            _ = [label.set_fontsize(self.config.tick_font_size) for label in ax.get_xticklabels()]\n\n            if p in base.log_scales:\n                ax.xaxis.set_major_locator(LogLocator(numticks=self.config.max_ticks))\n            else:\n                ax.xaxis.set_major_locator(MaxNLocator(self.config.max_ticks, prune=\"lower\"))\n                ax.xaxis.set_major_formatter(formatter)\n        ax.set_xlim(base.extents.get(p) or self._get_parameter_extents(p, base.chains))\n\n        max_val = -np.inf\n        for chain in base.chains:\n            if not chain.plot_contour:\n                continue\n            if p in chain.plotting_columns:\n                param_summary = summary and p not in base.blind\n                m = self._plot_bars(ax, p, chain, summary=param_summary)\n                if max_val is None or m &gt; max_val:\n                    max_val = m\n        plot_truths(ax, self.parent._truths, py=p)\n        ax.set_ylim(0, 1.1 * max_val)\n        ax.set_xlabel(p, fontsize=self.config.label_font_size)\n\n    add_watermark(fig, None, figsize, self.config, size_scale=0.8)\n    self._save_fig(fig, filename, dpi=self.config.dpi)\n    return fig\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.plot_summary","title":"plot_summary","text":"<pre><code>plot_summary(\n    chains: list[ChainName | Chain] | None = None,\n    columns: list[ColumnName] | None = None,\n    filename: list[str | Path] | str | Path | None = None,\n    figsize: float = 1.0,\n    errorbar: bool = False,\n    extra_parameter_spacing: float = 1.0,\n    vertical_spacing_ratio: float = 1.0,\n) -&gt; Figure\n</code></pre> <p>Plots parameter summaries</p> <p>This plot is more for a sanity or consistency check than for use with final results. Plotting this before plotting with :func:<code>plot</code> allows you to quickly see if the chains give well behaved distributions, or if certain parameters are suspect or require a greater burn in period.</p> <p>Parameters:</p> Name Type Description Default <code>chains</code> <code>list[ChainName | Chain] | None</code> <p>Used to specify which chain to show if more than one chain is loaded in. Can be an integer, specifying the chain index, or a str, specifying the chain name.</p> <code>None</code> <code>columns</code> <code>list[ColumnName] | None</code> <p>If set, only creates a plot for those specific parameters (if list). If an integer is given, only plots the fist so many parameters.</p> <code>None</code> <code>filename</code> <code>list[str | Path] | str | Path | None</code> <p>If set, saves the figure to this location</p> <code>None</code> <code>figsize</code> <code>float</code> <p>Scale horizontal and vertical figure size.</p> <code>1.0</code> <code>errorbar</code> <code>bool</code> <p>Whether to onle plot an error bar, instead of the marginalised distribution.</p> <code>False</code> <code>include_truth_chain</code> <p>If you specify another chain as the truth chain, determine if it should still be plotted.</p> required <code>extra_parameter_spacing</code> <code>float</code> <p>Increase horizontal space for parameter values</p> <code>1.0</code> <code>vertical_spacing_ratio</code> <code>float</code> <p>Increase vertical space for each model</p> <code>1.0</code> <p>Returns:     the matplotlib figure created</p> Source code in <code>src/chainconsumer/plotter.py</code> <pre><code>def plot_summary(\n    self,\n    chains: list[ChainName | Chain] | None = None,\n    columns: list[ColumnName] | None = None,\n    filename: list[str | Path] | str | Path | None = None,\n    figsize: float = 1.0,\n    errorbar: bool = False,\n    extra_parameter_spacing: float = 1.0,\n    vertical_spacing_ratio: float = 1.0,\n) -&gt; Figure:  # pragma: no cover\n    \"\"\"Plots parameter summaries\n\n    This plot is more for a sanity or consistency check than for use with final results.\n    Plotting this before plotting with :func:`plot` allows you to quickly see if the\n    chains give well behaved distributions, or if certain parameters are suspect\n    or require a greater burn in period.\n\n    Args:\n        chains:\n            Used to specify which chain to show if more than one chain is loaded in.\n            Can be an integer, specifying the\n            chain index, or a str, specifying the chain name.\n        columns:\n            If set, only creates a plot for those specific parameters (if list). If an\n            integer is given, only plots the fist so many parameters.\n        filename:\n            If set, saves the figure to this location\n        figsize:\n            Scale horizontal and vertical figure size.\n        errorbar:\n            Whether to onle plot an error bar, instead of the marginalised distribution.\n        include_truth_chain:\n            If you specify another chain as the truth chain, determine if it should still\n            be plotted.\n        extra_parameter_spacing:\n            Increase horizontal space for parameter values\n        vertical_spacing_ratio:\n            Increase vertical space for each model\n    Returns:\n        the matplotlib figure created\n\n    \"\"\"\n    wide_extents = not errorbar\n    base = self._sanitise(\n        chains,\n        columns,\n        self.config.extents,\n        blind=self.config.blind,\n        log_scales=self.config.log_scales,\n        wide_extents=wide_extents,\n    )\n\n    # We have a bit of fun to go from chain names to the width of the\n    # subplot used to display said names\n    max_param = self._get_size_of_texts(base.columns)\n    fid_dpi = 65  # Seriously I have no idea what value this should be\n    param_width = extra_parameter_spacing + max(0.5, max_param / fid_dpi)\n    max_model_name = self._get_size_of_texts([chain.name for chain in base.chains])\n    model_width = 0.25 + (max_model_name / fid_dpi)\n    gridspec_kw = {\n        \"width_ratios\": [model_width] + [param_width] * len(base.columns),\n        \"height_ratios\": [1] * len(base.chains),\n    }\n    ncols = 1 + len(base.columns)\n    top_spacing = 0.3\n    bottom_spacing = 0.2\n    row_height = (0.5 if errorbar else 0.8) * vertical_spacing_ratio\n    width = param_width * len(base.columns) + model_width\n    height = top_spacing + bottom_spacing + row_height * len(base.chains)\n    top_ratio = 1 - (top_spacing / height)\n    bottom_ratio = bottom_spacing / height\n\n    fig_size = (width * figsize, height * figsize)\n    fig, axes = plt.subplots(\n        nrows=len(base.chains), ncols=ncols, figsize=fig_size, squeeze=False, gridspec_kw=gridspec_kw\n    )\n    fig.subplots_adjust(left=0.05, right=0.95, top=top_ratio, bottom=bottom_ratio, wspace=0.0, hspace=0.0)\n    label_font_size = self.config.label_font_size\n    legend_color_text = self.config.legend_color_text\n\n    max_vals: dict[ColumnName, float] = {}\n    num_chains = len(base.chains)\n    for i, axes_row in enumerate(axes):\n        chain = base.chains[i]\n        colour = colors.format(chain.color)\n\n        # First one put name of model\n        ax_first = axes_row[0]\n        ax_first.set_axis_off()\n        text_colour = \"k\" if not legend_color_text else colour\n        ax_first.text(\n            0,\n            0.5,\n            chain.name,\n            transform=ax_first.transAxes,\n            fontsize=label_font_size,\n            verticalalignment=\"center\",\n            color=text_colour,\n            weight=\"medium\",\n        )\n        axes_for_summaries = axes_row[1:]\n\n        for ax, p in zip(axes_for_summaries, base.columns, strict=False):\n            # Set up the frames\n            if i &gt; 0:\n                ax.spines[\"top\"].set_visible(False)\n            if i &lt; (num_chains - 1):\n                ax.spines[\"bottom\"].set_visible(False)\n            if i &lt; (num_chains - 1) or p in base.blind:\n                ax.set_xticks([])\n            ax.set_yticks([])\n            ax.set_xlim(base.extents[p])\n            if p in base.log_scales:\n                ax.set_xscale(\"log\")\n\n            # Put title in\n            if i == 0:\n                ax.set_title(self.config.get_label(p), fontsize=label_font_size)\n\n            # Add truth values\n            for truth in self.parent._truths:\n                truth_value = truth.location.get(p)\n                if truth_value is not None:\n                    ax.axvline(truth_value, **truth._kwargs)\n\n            # Skip if this chain doesn't have the parameter\n            if p not in chain.data_columns:\n                continue\n\n            # Plot the good stuff\n            if errorbar:\n                fv = self.parent.analysis.get_parameter_summary(chain, p)\n                if fv is None or fv.all_none:\n                    continue\n                if fv.lower is not None and fv.upper is not None:\n                    diff = np.abs(np.diff(fv.array))\n                    ax.errorbar([fv.center], 0, xerr=[[diff[0]], [diff[1]]], fmt=\"o\", color=colour)\n            else:\n                m = self._plot_bars(ax, p, chain)\n                if max_vals.get(p) is None or m &gt; max_vals[p]:\n                    max_vals[p] = m\n\n    for axes_row in axes:\n        for ax, p in zip(axes_row, base.columns, strict=False):\n            if not errorbar:\n                ax.set_ylim(0, 1.1 * max_vals[p])\n\n    add_watermark(fig, None, fig_size, self.config, size_scale=0.8)\n    self._save_fig(fig, filename, dpi=self.config.dpi)\n\n    return fig\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.set_rc_params","title":"set_rc_params","text":"<pre><code>set_rc_params() -&gt; None\n</code></pre> Source code in <code>src/chainconsumer/plotter.py</code> <pre><code>def set_rc_params(self) -&gt; None:\n    if self.config.usetex is not None:\n        plt.rc(\"text\", usetex=self.config.usetex)\n    if self.config.serif is not None:\n        plt.rc(\"font\", family=(\"serif\" if self.config.serif else \"sans-serif\"))\n</code></pre>"},{"location":"api/plotter/#chainconsumer.plotter.Plotter.restore_rc_params","title":"restore_rc_params","text":"<pre><code>restore_rc_params()\n</code></pre> <p>Restores the matplotlib rc parameters modified by usetex and serif.</p> <p>Unfortunately this cannot be automated because you cannot invoke it whilst you have an active figure object or matplotlib will destroy you. So do all your plotting, close the plots, and then you can call this.</p> Source code in <code>src/chainconsumer/plotter.py</code> <pre><code>def restore_rc_params(self):\n    \"\"\"Restores the matplotlib rc parameters modified by usetex and serif.\n\n    Unfortunately this cannot be automated because you cannot invoke it whilst you have\n    an active figure object or matplotlib will destroy you. So do all your plotting, close\n    the plots, and then you can call this.\n    \"\"\"\n    plt.rc(\"text\", usetex=self.usetex_old)\n    plt.rc(\"font\", family=self.serif_old)\n</code></pre>"},{"location":"api/truth/","title":"Truth","text":""},{"location":"api/truth/#chainconsumer.Truth","title":"chainconsumer.Truth","text":"<p>               Bases: <code>BetterBase</code></p> Source code in <code>src/chainconsumer/truth.py</code> <pre><code>class Truth(BetterBase):\n    location: dict[str, float] = Field(\n        default=...,\n        description=\"The truth value, either as dictionary or pandas series which will be converted to a dict)\",\n    )\n    name: str | None = Field(default=None, description=\"The name of the truth line\")\n    color: ColorInput = Field(default=\"black\", description=\"The color of the truth line\")\n    edge_color: ColorInput | None = Field(\n        default=None, description=\"The edge color of the truth marker if the marker is filled. If None, uses `color`\"\n    )\n    line_width: float = Field(default=1.0, description=\"The width of the truth line\")\n    line_style: str = Field(default=\"--\", description=\"The style of the truth line\")\n    alpha: float = Field(default=1.0, description=\"The alpha of the truth line\")\n    zorder: int = Field(default=100, description=\"The zorder of the truth line\")\n    marker: str | None = Field(default=None, description=\"The truth marker style for the contour plots\")\n    marker_size: float = Field(default=150.0, description=\"The truth marker size for the contour plots\")\n    marker_edge_width: float = Field(\n        default=_DEFAULT_EDGE_WIDTH, description=\"The truth marker edge width for the contour plots\"\n    )\n\n    @field_validator(\"location\")\n    @classmethod\n    def _ensure_dict(cls, v):\n        if isinstance(v, dict):\n            return v\n        elif isinstance(v, pd.Series):\n            return v.to_dict()\n        raise ValidationError(\"Truth must be a dict or a pandas Series\")\n\n    @model_validator(mode=\"after\")\n    def validate_model(self):\n        if self.marker is not None and not self.is_filled_marker and self.marker_edge_width &gt; _DEFAULT_EDGE_WIDTH:\n            msg = (\n                f\"It seems you are trying to make the marker {self.marker} thicker. \"\n                \"Alas, this is not possible. Matplotlib only lets you make the marker \"\n                \"edge thicker if the marker is filled. Which, FYI, means picking from \"\n                \"one of the following markers: \"\n                f\"{', '.join(Line2D.filled_markers)}\"\n            )\n            raise ValueError(msg)\n        return self\n\n    @property\n    def is_filled_marker(self) -&gt; bool:\n        return self.marker in Line2D.filled_markers\n\n    @property\n    def _kwargs(self) -&gt; dict[str, Any]:\n        return {\n            \"ls\": self.line_style,\n            \"c\": self.color,\n            \"lw\": self.line_width,\n            \"alpha\": self.alpha,\n            \"zorder\": self.zorder,\n        }\n\n    @property\n    def _marker_kwargs(self) -&gt; dict[str, Any]:\n        result = {\n            \"marker\": self.marker,\n            \"s\": self.marker_size,\n            \"color\": self.color,\n            \"alpha\": self.alpha,\n            \"zorder\": self.zorder,\n        }\n        if self.is_filled_marker:\n            result[\"edgecolor\"] = self.edge_color if self.edge_color is not None else self.color\n            result[\"facecolor\"] = self.color\n            result[\"linewidth\"] = self.marker_edge_width\n        return result\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: dict[str, float] = Field(\n    default=...,\n    description=\"The truth value, either as dictionary or pandas series which will be converted to a dict)\",\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = Field(\n    default=None, description=\"The name of the truth line\"\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.color","title":"color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>color: ColorInput = Field(\n    default=\"black\",\n    description=\"The color of the truth line\",\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.edge_color","title":"edge_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>edge_color: ColorInput | None = Field(\n    default=None,\n    description=\"The edge color of the truth marker if the marker is filled. If None, uses `color`\",\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.line_width","title":"line_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_width: float = Field(\n    default=1.0, description=\"The width of the truth line\"\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.line_style","title":"line_style  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>line_style: str = Field(\n    default=\"--\", description=\"The style of the truth line\"\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: float = Field(\n    default=1.0, description=\"The alpha of the truth line\"\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.zorder","title":"zorder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zorder: int = Field(\n    default=100, description=\"The zorder of the truth line\"\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.marker","title":"marker  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>marker: str | None = Field(\n    default=None,\n    description=\"The truth marker style for the contour plots\",\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.marker_size","title":"marker_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>marker_size: float = Field(\n    default=150.0,\n    description=\"The truth marker size for the contour plots\",\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.marker_edge_width","title":"marker_edge_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>marker_edge_width: float = Field(\n    default=_DEFAULT_EDGE_WIDTH,\n    description=\"The truth marker edge width for the contour plots\",\n)\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.is_filled_marker","title":"is_filled_marker  <code>property</code>","text":"<pre><code>is_filled_marker: bool\n</code></pre>"},{"location":"api/truth/#chainconsumer.Truth.validate_model","title":"validate_model","text":"<pre><code>validate_model()\n</code></pre> Source code in <code>src/chainconsumer/truth.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_model(self):\n    if self.marker is not None and not self.is_filled_marker and self.marker_edge_width &gt; _DEFAULT_EDGE_WIDTH:\n        msg = (\n            f\"It seems you are trying to make the marker {self.marker} thicker. \"\n            \"Alas, this is not possible. Matplotlib only lets you make the marker \"\n            \"edge thicker if the marker is filled. Which, FYI, means picking from \"\n            \"one of the following markers: \"\n            f\"{', '.join(Line2D.filled_markers)}\"\n        )\n        raise ValueError(msg)\n    return self\n</code></pre>"},{"location":"generated/gallery/","title":"Basic Examples","text":"<p>All the basics laid out in a few short examples.</p> <p> Introduction to Contours </p> <p> Introduction to Summaries </p> <p> Introduction to LaTeX Tables </p> <p> Introduction to Distributions </p> <p> Introduction to Walks </p> <p> Using external samples </p> <p> Custom Axes </p> <p> Multimodal distributions </p>"},{"location":"generated/gallery/#specific-examples","title":"Specific Examples","text":"<p> Plotting Grid Data </p> <p> Blinding Plots </p> <p> KDE </p> <p> Dividing Chains </p> <p> Miscellaneous Visual Options </p> <p> Multiple Truth Values </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:33.977 total execution time for generated_gallery files:</p> <p>+-------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_5_emcee_arviz_numpyro (docs/examples/plot_5_emcee_arviz_numpyro.py) | 00:18.985 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_0_contours (docs/examples/plot_0_contours.py)                                  | 00:05.842 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_1_summary (docs/examples/plot_1_summary.py)                                     | 00:03.866 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_4_walks (docs/examples/plot_4_walks.py)                                           | 00:01.670 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_3_distributions (docs/examples/plot_3_distributions.py)                   | 00:01.468 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_7_multimodal_chains (docs/examples/plot_7_multimodal_chains.py)       | 00:01.139 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_2_textual_output (docs/examples/plot_2_textual_output.py)                | 00:00.538 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_6_custom_axes (docs/examples/plot_6_custom_axes.py)                         | 00:00.469 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/plot_0_contours/","title":"Introduction to Contours","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_0_contours/#introduction-to-contours","title":"Introduction to Contours","text":"<p>At the most basic, we take a contour as a pandas DataFrame and let ChainConsumer handle the defaults and display.</p> <pre><code>from chainconsumer import Chain, ChainConfig, ChainConsumer, PlotConfig, Truth, make_sample\n\n# Here's what you might start with\ndf = make_sample(num_dimensions=2, seed=1)\nprint(df.head())\n</code></pre> <p>Out:</p> <pre><code>          A         B  log_posterior\n0 -0.416281  3.926871      -2.170950\n1  0.449313  5.917570      -1.893852\n2 -0.797686  4.530800      -1.737146\n3  1.574312  5.858611      -2.781213\n4  0.042566  5.421272      -1.578588\n</code></pre> <pre><code># And now we give this to chainconsumer\nc = ChainConsumer()\nc.add_chain(Chain(samples=df, name=\"An Example Contour\"))\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>If we wanted to customise the chain, that's easy enough to do.</p> <pre><code># Here's a convenience function for you\nchain2 = Chain.from_covariance(\n    [3.0, 1.0],\n    [[1.0, -1], [-1, 2]],\n    columns=[\"A\", \"B\"],\n    name=\"Another contour!\",\n    color=\"#065f46\",\n    linestyle=\":\",\n)\nc.add_chain(chain2)\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/plot_0_contours/#customising-chains","title":"Customising Chains","text":"<p>There's a lot you can configure using chains, and to make it easy, Chains are defined as pydantic base models so you can easily see the default and values you can pass in. Don't worry, there will be plenty of very specific examples in a sub gallery you can check out, but as a final one for here, let's add markers and truth values.</p> <pre><code>c.add_marker(location={\"A\": 0, \"B\": 2}, name=\"A point\", color=\"orange\", marker_style=\"P\", marker_size=50)\nc.add_truth(Truth(location={\"A\": 0, \"B\": 5}))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/plot_0_contours/#weights-and-posteriors","title":"Weights and Posteriors","text":"<p>If you provide the log posteriors in the chain, you can ask for the maximum probability point to be plotted as well. Similarly, if you have samples with non-uniform weights, you can specify the weights column as well.</p> <p>To keep this clean, let's remake everything. I'm going to add an extra few columns into our dataframe. You'll see what they do</p> <pre><code>df2 = df.assign(C=lambda x: x[\"A\"] + x[\"B\"])\n\nc = ChainConsumer()\n# Customise the chain when you add it\nchain = Chain(\n    samples=df2,\n    name=\"Example\",\n    color=\"k\",\n    plot_point=True,\n    plot_cloud=True,\n    marker_style=\"*\",\n    marker_size=100,\n    num_cloud=30000,\n    shade=False,\n    linewidth=2.0,\n    cmap=\"magma\",\n    show_contour_labels=True,\n    color_param=\"C\",\n)\nc.add_chain(chain)\n# You can also override *all* chains at once like so\n# Notice that Chain is a child of ChainConfig\n# So you could override base properties like line weights... but not samples\nc.set_override(ChainConfig(sigmas=[0, 1, 2, 3]))\nc.add_truth(Truth(location={\"A\": 0, \"B\": 5}, color=\"#500724\"))\n\n# And if we want to change the plot itself in some way, we can do that via\nc.set_plot_config(\n    PlotConfig(\n        flip=True,\n        labels={\"A\": \"$A$\", \"B\": \"$B$\", \"C\": r\"$\\alpha^2$\"},\n        contour_label_font_size=12,\n    )\n)\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>Here the maximum posterior value is used to plot the star-shaped point. A truth line is added in dark red, and instead of plotting $x_3$ as another contour, we use it to provide coloured scatter plots. This is useful if the parameter isn't constrained and has some dependency.</p> <p>I have used this in the past to show how adding different priors to Hubble's constant (as the color parameter) would pull our fits in different directions.</p> <p>Now, I am expecting a few comments like: \"But Sam, it was easier to do everything in one line before, instead of all these objects.\"</p> <p>Having everything as kwargs being passed through made the code a nightmare, type hints impossible, and extensibility poor. By trying to separate things out into appropriate dataclasses, I am hoping it is a lot easier for people to contribute to this code base in the future.</p> <p>Total running time of the script: ( 0 minutes  5.842 seconds)</p> <p> Download Python source code: plot_0_contours.py</p> <p> Download Jupyter notebook: plot_0_contours.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_1_summary/","title":"Introduction to Summaries","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_1_summary/#introduction-to-summaries","title":"Introduction to Summaries","text":"<p>When you have a few chains and want to contrast them all with each other, you probably want a summary plot.</p> <p>To show you how they work, let's make some sample data that all has the same average.</p> <pre><code>from chainconsumer import Chain, ChainConfig, ChainConsumer, PlotConfig, Truth, make_sample\n\n# Here's what you might start with\ndf_1 = make_sample(num_dimensions=4, seed=1)\ndf_2 = make_sample(num_dimensions=5, seed=2)\nprint(df_1.head())\n</code></pre> <p>Out:</p> <pre><code>          A         B          C          D  log_posterior\n0 -0.344316  5.497409  10.171751  14.838856      -2.055036\n1 -1.441640  6.412585  11.184474  13.722961      -3.611740\n2  0.554166  5.877073  10.758878  14.557307      -4.953687\n3  0.534155  4.404624   8.879323  16.288038      -2.949890\n4  0.102369  5.624179   8.291829  16.897482      -5.213089\n</code></pre>"},{"location":"generated/gallery/plot_1_summary/#using-distributions","title":"Using distributions","text":"<pre><code># And now we give this to chainconsumer\nc = ChainConsumer()\nc.add_chain(Chain(samples=df_1, name=\"An Example Contour\"))\nc.add_chain(Chain(samples=df_2, name=\"A Different Contour\"))\nfig = c.plotter.plot_summary()\n</code></pre>"},{"location":"generated/gallery/plot_1_summary/#using-errorbars","title":"Using Errorbars","text":"<p>Note that because the errorbar kwarg is specific to this function it is not part of the <code>PlotConfig</code> class.</p> <pre><code>fig = c.plotter.plot_summary(errorbar=True)\n</code></pre> <p></p> <p>The other features of ChainConsumer should work with summaries too.</p> <p>For example, truth values should work just fine.</p> <pre><code>c.add_truth(Truth(location={\"A\": 0, \"B\": 1}, line_style=\":\", color=\"red\"))\nfig = c.plotter.plot_summary(errorbar=True, vertical_spacing_ratio=2.0)\n</code></pre> <p></p> <p>And similarly, our overrides are generic and so effect this method too.</p> <pre><code>c.set_override(ChainConfig(bar_shade=False))\nc.set_plot_config(PlotConfig(watermark=\"Preliminary\", blind=[\"E\"]))\nfig = c.plotter.plot_summary()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  3.866 seconds)</p> <p> Download Python source code: plot_1_summary.py</p> <p> Download Jupyter notebook: plot_1_summary.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_2_textual_output/","title":"Introduction to LaTeX Tables","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_2_textual_output/#introduction-to-latex-tables","title":"Introduction to LaTeX Tables","text":"<p>Because typing those things out is a massive pain in the ass.</p> <pre><code>from chainconsumer import Chain, ChainConsumer, Truth, make_sample\n\n# Here's a sample dataset\nn_1, n_2 = 100000, 200000\ndf_1 = make_sample(num_dimensions=2, seed=0, num_points=n_1)\ndf_2 = make_sample(num_dimensions=2, seed=1, num_points=n_2)\n\n\n# Here's what the plot looks like:\nc = ChainConsumer()\nc.add_chain(Chain(samples=df_1, name=\"Model A\", num_free_params=1, num_eff_data_points=n_1))\nc.add_chain(Chain(samples=df_2, name=\"Model B\", num_free_params=2, num_eff_data_points=n_2))\nc.add_truth(Truth(location={\"A\": 0, \"B\": 1}))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/plot_2_textual_output/#comparing-models","title":"Comparing Models","text":"<p>Provided you have the log posteriors, comparing models is easy.</p> <pre><code>latex_table = c.comparison.comparison_table()\nprint(latex_table)\n</code></pre> <p>Out:</p> <pre><code>\\begin{table}\n    \\centering\n    \\caption{}\n    \\label{tab:model_comp}\n    \\begin{tabular}{cccc}\n        \\hline\n        Model &amp; AIC &amp; BIC  &amp; DIC  \\\\ \n        \\hline\n        Model B  &amp;    1.2    &amp;   12.1    &amp;    0.0   \\\\ \n        Model A  &amp;    0.0    &amp;    0.0    &amp;    0.8   \\\\ \n        \\hline\n    \\end{tabular}\n\\end{table}\n</code></pre> <p>Granted, it's hard to read a LaTeX table. It'll come out something like this, though I took a screenshot a while ago and the data has changed. You get the idea though...</p> <p></p>"},{"location":"generated/gallery/plot_2_textual_output/#summarising-parameters","title":"Summarising Parameters","text":"<p>Alright, so what if you've compared models and you're happy and want to publish that paper!</p> <p>You can get a LaTeX table of the summary statistics as well.</p> <pre><code>print(c.analysis.get_latex_table())\n</code></pre> <p>Out:</p> <pre><code>\\begin{table}\n    \\centering\n    \\caption{}\n    \\label{tab:model_params}\n    \\begin{tabular}{ccc}\n        \\hline\n                Model &amp; A &amp; B \\\\ \n                \\hline\n                Model A &amp; $-0.10^{+1.11}_{-0.91}$ &amp; $5.06^{+0.94}_{-1.08}$ \\\\ \n                Model B &amp; $-0.01^{+1.03}_{-0.99}$ &amp; $5.08^{+0.93}_{-1.08}$ \\\\ \n                \\hline\n    \\end{tabular}\n\\end{table}\n</code></pre> <p>Which would look like this (though I saved this screenshot out a while ago too)</p> <p></p> <p>And sometimes you might want this table transposed if you have a lot of parameters and not many models to compare.</p> <pre><code>print(c.analysis.get_latex_table(transpose=True, caption=\"The best table\"))\n</code></pre> <p>Out:</p> <pre><code>\\begin{table}\n    \\centering\n    \\caption{The best table}\n    \\label{tab:model_params}\n    \\begin{tabular}{ccc}\n        \\hline\n                Parameter &amp; Model A &amp; Model B \\\\ \n                \\hline\n                A &amp; $-0.10^{+1.11}_{-0.91}$ &amp; $-0.01^{+1.03}_{-0.99}$ \\\\ \n                B &amp; $5.06^{+0.94}_{-1.08}$ &amp; $5.08^{+0.93}_{-1.08}$ \\\\ \n                \\hline\n    \\end{tabular}\n\\end{table}\n</code></pre> <p>There are other things you can do if you dig around in the API, like correlations and covariance.</p> <pre><code>print(c.analysis.get_covariance_table(\"Model A\"))\n</code></pre> <p>Out:</p> <pre><code>\\begin{table}\n    \\centering\n    \\caption{Parameter Covariance}\n    \\label{tab:parameter_covariance}\n    \\begin{tabular}{c|cc}\n         &amp; A &amp; B\\\\ \n        \\hline\n        A &amp;  1.00 &amp;  0.27 \\\\ \n        B &amp;  0.27 &amp;  1.00 \\\\ \n        \\hline\n    \\end{tabular}\n\\end{table}\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.538 seconds)</p> <p> Download Python source code: plot_2_textual_output.py</p> <p> Download Jupyter notebook: plot_2_textual_output.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_3_distributions/","title":"Introduction to Distributions","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_3_distributions/#introduction-to-distributions","title":"Introduction to Distributions","text":"<p>When you have a few chains and want to contrast them all with each other, you probably want a summary plot.</p> <p>To show you how they work, let's make some sample data that all has the same average.</p> <pre><code>from chainconsumer import Chain, ChainConsumer, Truth, make_sample\n\n# Here's what you might start with\ndf_1 = make_sample(num_dimensions=4, seed=1, randomise_mean=True)\ndf_2 = make_sample(num_dimensions=5, seed=2, randomise_mean=True)\nprint(df_1.head())\n</code></pre> <p>Out:</p> <pre><code>          A         B         C          D  log_posterior\n0  1.165623  5.284409  8.374808  16.421808      -9.082802\n1  0.336769  5.304098  8.714608  15.086368      -4.100887\n2 -0.804581  6.031140  9.373729  14.695598      -3.213869\n3 -1.012814  4.219814  9.947640  13.324333      -3.929196\n4  0.956188  2.005424  6.705883  16.512909      -8.334207\n</code></pre>"},{"location":"generated/gallery/plot_3_distributions/#using-distributions","title":"Using distributions","text":"<pre><code># And now we give this to chainconsumer\nc = ChainConsumer()\nc.add_chain(Chain(samples=df_1, name=\"An Example Contour\"))\nfig = c.plotter.plot_distributions()\n</code></pre> <p>If you want the summary stats you'll need to keep it just one chain. And if you don't want them, you can pass <code>summarise=False</code> to the <code>PlotConfig</code>.</p> <p>When you add a second chain, you'll see the summaries disappear.</p> <pre><code>c.add_chain(Chain(samples=df_2, name=\"Another contour!\"))\nc.add_truth(Truth(location={\"A\": 0, \"B\": 0}))\nfig = c.plotter.plot_distributions(col_wrap=3, columns=[\"A\", \"B\"])\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  1.468 seconds)</p> <p> Download Python source code: plot_3_distributions.py</p> <p> Download Jupyter notebook: plot_3_distributions.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_4_walks/","title":"Introduction to Walks","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_4_walks/#introduction-to-walks","title":"Introduction to Walks","text":"<p>Want to see if your chain is behaving nicely? Use a walk!</p> <pre><code>from chainconsumer import Chain, ChainConsumer, Truth, make_sample\n\n# Here's a sample dataset\ndf_1 = make_sample(num_dimensions=4, seed=1, randomise_mean=True, num_points=10000)\n\n# And now we give this to chainconsumer\nc = ChainConsumer()\nc.add_chain(Chain(samples=df_1, name=\"An Example Contour\"))\nfig = c.plotter.plot_walks()\n</code></pre> <p></p> <p>You can add other chains in if you want, though it can get messy to see things.</p> <p>To reduce the mess, try turning on convolve, which will get you a smoothed out version of the walk. And truth lines are always nice.</p> <pre><code>c.add_truth(Truth(location={\"A\": 0, \"B\": 0}))\nfig = c.plotter.plot_walks(convolve=100)\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  1.670 seconds)</p> <p> Download Python source code: plot_4_walks.py</p> <p> Download Jupyter notebook: plot_4_walks.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_5_emcee_arviz_numpyro/","title":"Using external samples","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_5_emcee_arviz_numpyro/#using-external-samples","title":"Using external samples","text":"<p><code>emcee</code>, <code>arviz</code>, and <code>numpyro</code> are all popular MCMC packages. ChainConsumer provides class methods to turn results from these packages into chains efficiently.</p> <p>If you want to request support for another type of chain, please open a discussion with a code example, and we can add it in. The brave may even provide a PR!</p> <pre><code>import arviz as az\nimport emcee\nimport numpy as np\nimport numpyro\nimport numpyro.distributions as dist\nfrom jax import random\nfrom numpyro.infer import MCMC, NUTS\nfrom scipy.stats import norm\n\nfrom chainconsumer import Chain, ChainConsumer\n</code></pre>"},{"location":"generated/gallery/plot_5_emcee_arviz_numpyro/#emcee","title":"Emcee","text":"<p>Let's make a dummy model here.</p> <pre><code># Of course, your code is probably a bit more complex\ndef run_emcee_mcmc(n_steps, n_walkers):\n    rng = np.random.default_rng(42)\n    observed_data = rng.normal(loc=1, scale=1, size=100)\n\n    def log_likelihood(theta, data):\n        mu, log_sigma = theta\n        return np.sum(norm.logpdf(data, mu, np.exp(log_sigma)))\n\n    def log_prior(theta):\n        mu, log_sigma = theta\n        if -10 &lt; mu &lt; 10 and -10 &lt; log_sigma &lt; 10:\n            return 0.0\n        return -np.inf\n\n    def log_probability(theta, data):\n        lp = log_prior(theta)\n        if not np.isfinite(lp):\n            return -np.inf\n        return lp + log_likelihood(theta, data)\n\n    ndim = 2\n    p0 = rng.uniform(low=0, high=1, size=(n_walkers, ndim))\n    sampler = emcee.EnsembleSampler(n_walkers, ndim, log_probability, args=(observed_data,))\n    sampler.run_mcmc(p0, n_steps, progress=False)\n\n    return sampler\n\n\nsampler = run_emcee_mcmc(8000, 16)\nparams = [r\"$\\mu$\", r\"$\\log(\\sigma)$\"]\nchain = Chain.from_emcee(sampler, params, \"an emcee chain\", discard=200, thin=2, color=\"indigo\")\nconsumer = ChainConsumer().add_chain(chain)\n</code></pre> <p>Let's plot the walks to make sure we've discard enough burn-in</p> <pre><code>fig = consumer.plotter.plot_walks()\n</code></pre> <p></p> <p>And then show the contours themselves</p> <pre><code>fig = consumer.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/plot_5_emcee_arviz_numpyro/#numpyro","title":"Numpyro","text":"<p>Let's start with numpyro. Again, let's make a dummy model we can sample from.</p> <pre><code>def run_numpyro_mcmc(n_steps, n_chains):\n    rng = np.random.default_rng(42)\n    observed_data = rng.normal(loc=0, scale=1, size=100)\n\n    def model(data):\n        # Prior\n        mu = numpyro.sample(\"mu\", dist.Normal(0, 10))\n        sigma = numpyro.sample(\"sigma\", dist.HalfNormal(10))\n\n        # Likelihood\n        with numpyro.plate(\"data\", size=len(data)):\n            numpyro.sample(\"obs\", dist.Normal(mu, sigma), obs=data)  # type: ignore\n\n    # Running MCMC\n    kernel = NUTS(model)\n    mcmc = MCMC(kernel, num_warmup=500, num_samples=n_steps, num_chains=n_chains, progress_bar=False)\n    rng_key = random.PRNGKey(0)\n    mcmc.run(rng_key, data=observed_data)\n\n    return mcmc\n\n\nmcmc = run_numpyro_mcmc(8000, 1)\nchain = Chain.from_numpyro(mcmc, \"numpyro chain\", color=\"teal\")\nconsumer = ChainConsumer().add_chain(chain)\n</code></pre> <p>Let's plot the walks to make sure we've discard enough burn-in</p> <pre><code>fig = consumer.plotter.plot_walks()\n</code></pre> <p></p> <p>And then show the contours themselves</p> <pre><code>fig = consumer.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/plot_5_emcee_arviz_numpyro/#arviz","title":"Arviz","text":"<p>To simplify the process, we're going to make our arviz sample from the numpyro one.</p> <pre><code>arviz_id = az.from_numpyro(mcmc)\nchain = Chain.from_arviz(arviz_id, \"arviz chain\", color=\"amber\")\nfig = ChainConsumer().add_chain(chain).plotter.plot()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  18.985 seconds)</p> <p> Download Python source code: plot_5_emcee_arviz_numpyro.py</p> <p> Download Jupyter notebook: plot_5_emcee_arviz_numpyro.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_6_custom_axes/","title":"Custom Axes","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_6_custom_axes/#custom-axes","title":"Custom Axes","text":"<p>A lot of the time you might have your own plots ready to go.</p> <p>In this case, you can manually invoke ChainConsumer's plotting functions.</p> <p>Here's an example, noting that there are also <code>plot_point</code>, <code>plot_surface</code> available that I haven't explicitly shown.</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom chainconsumer import Chain, Truth, make_sample\nfrom chainconsumer.plotting import plot_contour, plot_truths\n</code></pre> <pre><code>df = make_sample(num_dimensions=2, seed=1)\n\n# Custom plotting code\nfig, axes = plt.subplots(ncols=2, figsize=(10, 5))\naxes[0].hist(df[\"A\"], bins=50, color=\"skyblue\", density=True)\n\n# We can use ChainConsumer to plot a truth value on top of this histogram\ntruth = Truth(location={\"A\": 0, \"B\": 5}, line_style=\":\")\nplot_truths(axes[0], [truth], px=\"A\")\n# And also add a contour to the other axis\nplot_contour(axes[1], Chain(samples=df, name=\"Example\"), px=\"A\", py=\"B\")\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.469 seconds)</p> <p> Download Python source code: plot_6_custom_axes.py</p> <p> Download Jupyter notebook: plot_6_custom_axes.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_7_multimodal_chains/","title":"Multimodal distributions","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_7_multimodal_chains/#multimodal-distributions","title":"Multimodal distributions","text":"<p><code>ChainConsumer</code> can handle cases where the distributions of your chains are multimodal.</p> <pre><code>import numpy as np\nimport pandas as pd\n\nfrom chainconsumer import Chain, ChainConsumer\n</code></pre> <p>First, let's build some dummy data</p> <pre><code>rng = np.random.default_rng(42)\nsize = 60_000\n\neta = rng.normal(loc=0.0, scale=0.8, size=size)\n\nphi = np.asarray(\n    [rng.gamma(shape=2.5, scale=0.4, size=size // 2) - 3.0, 3.0 - rng.gamma(shape=5.0, scale=0.35, size=(size // 2))]\n).flatten()\n\nrng.shuffle(phi)\n\ndf = pd.DataFrame({\"eta\": eta, \"phi\": phi})\n</code></pre> <p>To build a multimodal chain, you simply have to pass <code>multimodal=True</code> when building the chain.</p> <pre><code>chain_multimodal = Chain(\n    samples=df.copy(),\n    name=\"posterior-multimodal\",\n    multimodal=True,  # &lt;- Here\n)\n</code></pre> <p>Now, if you add this <code>Chain</code> to a plotter, it will try to look for sub-intervals and display them.</p> <pre><code>cc = ChainConsumer()\ncc.add_chain(chain_multimodal)\nfig = cc.plotter.plot()\n</code></pre> <p></p> <p>Let's compare with what would happen if you don't use a multimodal chain. We use the same data as before but don't tell <code>ChainConsumer</code> that we expect the chains to be multimodal.</p> <pre><code>chain_unimodal = Chain(samples=df.copy(), name=\"posterior-unimodal\", multimodal=False)\n\ncc.add_chain(chain_unimodal)\nfig = cc.plotter.plot()\n</code></pre> <p></p> <p>Let's try with even more modes.</p> <pre><code>eta = np.asarray(\n    [\n        rng.normal(loc=-3, scale=0.8, size=size // 3),\n        rng.normal(loc=0.0, scale=0.8, size=size // 3),\n        rng.normal(loc=+3, scale=0.8, size=size // 3),\n    ]\n).flatten()\n\n\nrng.shuffle(eta)\n\ndf = pd.DataFrame({\"eta\": eta, \"phi\": phi})\n\nchain_multimodal = Chain(samples=df.copy(), name=\"posterior-multimodal\", multimodal=True)\n\ncc = ChainConsumer()\ncc.add_chain(chain_multimodal)\nfig = cc.plotter.plot()\nfig.tight_layout()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  1.139 seconds)</p> <p> Download Python source code: plot_7_multimodal_chains.py</p> <p> Download Jupyter notebook: plot_7_multimodal_chains.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/advanced_examples/mg_execution_times/","title":"Computation times","text":"<p>00:29.370 total execution time for generated_gallery_advanced_examples files:</p> <p>+-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_2_kde (docs/examples/advanced_examples/plot_2_kde.py)                                                       | 00:09.885 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_4_misc_chain_visuals (docs/examples/advanced_examples/plot_4_misc_chain_visuals.py)          | 00:08.901 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_1_blinding (docs/examples/advanced_examples/plot_1_blinding.py)                                        | 00:07.642 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_5_multiple_truth_values (docs/examples/advanced_examples/plot_5_multiple_truth_values.py) | 00:02.375 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_3_divide_chains (docs/examples/advanced_examples/plot_3_divide_chains.py)                         | 00:00.335 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_0_grid (docs/examples/advanced_examples/plot_0_grid.py)                                                    | 00:00.231 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/advanced_examples/plot_0_grid/","title":"Plotting Grid Data","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/advanced_examples/plot_0_grid/#plotting-grid-data","title":"Plotting Grid Data","text":"<p>If you don't have Monte Carlo chains, and have grid evaluations instead, that's fine too!</p> <p>Just flatten your grid, set the weights to the grid evaluation, and set the grid flag. Here is a nice diamond that you get from modifying a simple multivariate normal distribution.</p> <p>Note that by default, grid data is not smoothed, though you can explicitly set the smooth parameter when you make the Chain object if you want.</p> <p>Note that you cannot use dictionary input with the grid method and not specify the full flattened array. This is because we cannot construct the meshgrid from a dictionary, as the order of the parameters is not preserved in the dictionary.</p> <p></p> <pre><code>import numpy as np\nimport pandas as pd\n\nfrom chainconsumer import Chain, ChainConsumer\n\nx, y = np.linspace(-3, 3, 50), np.linspace(-7, 7, 100)\nxx, yy = np.meshgrid(x, y, indexing=\"ij\")\nlikelihood = np.exp(-0.5 * (xx * xx + yy * yy / 4 + np.abs(xx * yy)))\ndf = pd.DataFrame({\"x\": xx.flatten(), \"y\": yy.flatten(), \"weight\": likelihood.flatten()})\n\nc = ChainConsumer()\nc.add_chain(Chain(samples=df, grid=True, name=\"Grid Data\"))\nfig = c.plotter.plot()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.231 seconds)</p> <p> Download Python source code: plot_0_grid.py</p> <p> Download Jupyter notebook: plot_0_grid.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/advanced_examples/plot_1_blinding/","title":"Blinding Plots","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/advanced_examples/plot_1_blinding/#blinding-plots","title":"Blinding Plots","text":"<p>You can blind parameters and not show axis labels very easily!</p> <p>Just give ChainConsumer the <code>blind</code> parameter when plotting. You can specify <code>True</code> to blind all parameters, or give it a string (or list of strings) detailing the specific parameters you want blinded!</p> <pre><code>from chainconsumer import Chain, ChainConsumer, PlotConfig, make_sample\n\ndf = make_sample(num_dimensions=4, seed=1)\nc = ChainConsumer()\nc.add_chain(Chain(samples=df, name=\"Blind Me!\"))\nc.set_plot_config(PlotConfig(blind=[\"A\", \"B\"]))\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>Notice the blinding applies to all plots</p> <pre><code>fig = c.plotter.plot_summary()\n</code></pre> <p></p> <pre><code>fig = c.plotter.plot_walks()\n</code></pre> <p></p> <pre><code>fig = c.plotter.plot_distributions()\n</code></pre> <p></p> <p>And the LaTeX output</p> <pre><code>print(c.analysis.get_latex_table())\n</code></pre> <p>Out:</p> <pre><code>\\begin{table}\n    \\centering\n    \\caption{}\n    \\label{tab:model_params}\n    \\begin{tabular}{ccc}\n        \\hline\n                Model &amp; C &amp; D \\\\ \n                \\hline\n                Blind Me! &amp; $10.0\\pm 1.0$ &amp; $15.01^{+0.99}_{-1.02}$ \\\\ \n                \\hline\n    \\end{tabular}\n\\end{table}\n</code></pre> <p>Total running time of the script: ( 0 minutes  7.642 seconds)</p> <p> Download Python source code: plot_1_blinding.py</p> <p> Download Jupyter notebook: plot_1_blinding.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/advanced_examples/plot_2_kde/","title":"KDE","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/advanced_examples/plot_2_kde/#kde","title":"KDE","text":"<p>I don't recommend using KDEs in general, as its very easy to have them inflate your contours if the bandpass isn't tuned well, and its hard to see when it's too large.</p> <p>Always run more samples if you can, instead of covering up a lack of data with some extra smoothing.</p> <p>But, if there's no other way, here's how you can do it.</p> <p>Notice how the KDE, unless its perfectly matched to your distribution, increases the width of the marginal distributions.</p> <p></p> <pre><code>from chainconsumer import Chain, ChainConsumer, PlotConfig, make_sample\n\ndf = make_sample(num_dimensions=2, seed=3, num_points=1000)\nc = ChainConsumer()\nc.add_chain(Chain(samples=df, name=\"No KDE\"))\nc.add_chain(Chain(samples=df + 1, name=\"KDE\", kde=1.0))\nc.add_chain(Chain(samples=df + 2, name=\"KDE that's too large\", kde=2.0))\nc.set_plot_config(PlotConfig(flip=True))\nfig = c.plotter.plot()\n</code></pre> <p>Total running time of the script: ( 0 minutes  9.885 seconds)</p> <p> Download Python source code: plot_2_kde.py</p> <p> Download Jupyter notebook: plot_2_kde.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/advanced_examples/plot_3_divide_chains/","title":"Dividing Chains","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/advanced_examples/plot_3_divide_chains/#dividing-chains","title":"Dividing Chains","text":"<p>It's common with algorithms like MH and other random walkers to have multiple walkers each providing their own chains. Typically, you want to verify each walker is burnt in, and then you put all of their samples into one chain.</p> <p>But, if your final samples are made up for four walkers each contributing 10k samples, you may want to inspect each walker's surface individually.</p> <p>In this toy example, all the chains are from the same random generator, so they're on top of each other. Except MCMC chains to not be as perfect.</p> <p></p> <p>Out:</p> <pre><code>/home/runner/work/ChainConsumer/ChainConsumer/.venv/lib/python3.13/site-packages/numpy/_core/fromnumeric.py:57: FutureWarning: 'DataFrame.swapaxes' is deprecated and will be removed in a future version. Please use 'DataFrame.transpose' instead.\n  return bound(*args, **kwds)\n</code></pre> <p></p> <pre><code>from chainconsumer import Chain, ChainConsumer, PlotConfig, make_sample\n\ndf = make_sample(num_dimensions=2, seed=3, num_points=40000)\n\nc = ChainConsumer()\ncombined = Chain(samples=df, name=\"Model\", walkers=4)\nfor chain in combined.divide():\n    c.add_chain(chain)\nc.set_plot_config(PlotConfig(flip=True))\nfig = c.plotter.plot()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.335 seconds)</p> <p> Download Python source code: plot_3_divide_chains.py</p> <p> Download Jupyter notebook: plot_3_divide_chains.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/","title":"Miscellaneous Visual Options","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#miscellaneous-visual-options","title":"Miscellaneous Visual Options","text":"<p>Rather than having one example for each option, let's condense things.</p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#shade-gradient","title":"Shade Gradient","text":"<p>Pretty simple - it controls how much visual difference there is in your contours.</p> <pre><code>import numpy as np\n\nfrom chainconsumer import Chain, ChainConfig, ChainConsumer, PlotConfig, make_sample\n\ndf1 = make_sample(num_dimensions=2, seed=3) - 1\ndf2 = make_sample(num_dimensions=2, seed=1) + 2\n\nc = ChainConsumer()\nc.add_chain(Chain(samples=df1, name=\"High Contrast\", color=\"emerald\", shade_gradient=2.0))\nc.add_chain(Chain(samples=df2, name=\"Low Contrast\", color=\"sky\", shade_gradient=0.2))\n\nc.set_plot_config(PlotConfig(flip=True))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#shade-alpha","title":"Shade Alpha","text":"<p>Controls how opaque the contours are. Like everything else, you can specify this when making the chain, or apply a single override to everything like so.</p> <pre><code>c.set_override(ChainConfig(shade_alpha=0.1))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#contour-labels","title":"Contour Labels","text":"<p>Add labels to contours. I used to have this configurable to be either sigma levels or percentages, but there was confusion over the 1D vs 2D sigma levels, in that $1\\sigma$ in a 2D gaussian is not 68% of the volume. So now we just do percentages.</p> <pre><code>c.set_override(ChainConfig(show_contour_labels=True))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#linestyles-and-widths","title":"Linestyles and widths","text":"<p>Fairly simple to do. To show different ones, I'll remake the chains, rather than having a single override. Note you could try something like <code>chain.line_width = 5</code>, but this is a sneaky override, and it won't be registered in the internal \"You set this attribute and didn't use the default when you made the chain, so don't screw with it.\"</p> <p>Nothing does screw with line width, or similar, but it's a good habit.</p> <pre><code>c2 = ChainConsumer()\nc2.add_chain(Chain(samples=df1, name=\"Thin dots\", color=\"emerald\", linestyle=\":\", linewidth=0.5))\nc2.add_chain(Chain(samples=df2, name=\"Thick dashes\", color=\"sky\", linestyle=\"--\", linewidth=2.0))\nfig = c2.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#marker-styles-and-sizes","title":"Marker styles and sizes","text":"<p>Provided you have a posterior column, you can plot the maximum probability point.</p> <pre><code>c.set_override(ChainConfig(plot_point=True, marker_style=\"P\", marker_size=100))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#cloud-and-sigma-levels","title":"Cloud and Sigma Levels","text":"<p>Choose custom sigma levels and display point cloud.</p> <pre><code>c.set_override(\n    ChainConfig(\n        shade_alpha=1.0,\n        sigmas=np.linspace(0, 1, 10).tolist(),\n        shade_gradient=1.0,\n        plot_cloud=True,\n    )\n)\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>Of course, you don't have to change both at once. Here's just a cloud. And also note that contours include the 2D marginalised distributions, hence why I am hising the histograms here (as they'll be empty).</p> <pre><code>c.set_override(ChainConfig(plot_cloud=True, plot_contour=False))\nc.set_plot_config(PlotConfig(plot_hists=False))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#smoothing-or-not","title":"Smoothing (or not)","text":"<p>The histograms behind the scene in ChainConsumer are smoothed. But you can turn this off. The higher the smoothing value, the more subidivisions of your bins there will be.</p> <pre><code>c.set_override(ChainConfig(smooth=0))\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>But changing the smoothing doesn't change the number of bins. That's separate.</p> <pre><code>c.set_override(ChainConfig(smooth=0, bins=10))\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>It's beautiful. And it's hard to find a nice balance.</p> <pre><code>c.set_override(ChainConfig(smooth=0, bins=100))\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#controlling-the-legend","title":"Controlling the legend","text":"<p>Sometimes we have a bunch of things we want to show, whether they are chains, markers, truth values, or something else. By default, ChainConsumer will try to show everything, but you specifically tell it to hide items on the legend.</p> <pre><code>c = ChainConsumer()\nc.add_chain(Chain(samples=df1, name=\"I'm in the legend!\"))\nc.add_chain(Chain(samples=df2, name=\"I'm not!\", show_label_in_legend=False))\nc.add_marker(location={\"A\": 2.5, \"B\": 7.5}, marker_size=100, name=\"Marker in legend!\")\nc.add_marker(location={\"A\": 2.5, \"B\": 1}, marker_size=100, name=\"Marker not in legend\", show_label_in_legend=False)\nfig = c.plotter.plot()\n</code></pre> <p></p>"},{"location":"generated/gallery/advanced_examples/plot_4_misc_chain_visuals/#changing-the-height-of-the-histogram","title":"Changing the height of the histogram","text":"<p>For very niche reasons, you may want to change the defaults so that the marginalised histograms on the diagonal are not normalised to unit area. You can set the <code>histogram_relative_height</code> value to change this, such that a value of 0.5 would mean \"Make the histogram half as tall\" and thus result in a normalised area of 0.5 instead of 1.0.</p> <pre><code>c = ChainConsumer()\nc.add_chain(Chain(samples=df1, name=\"Normal histogram\"))\nc.add_chain(Chain(samples=df2, name=\"Small histogram\", histogram_relative_height=0.2))\nc.set_plot_config(PlotConfig(flip=False))\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  8.901 seconds)</p> <p> Download Python source code: plot_4_misc_chain_visuals.py</p> <p> Download Jupyter notebook: plot_4_misc_chain_visuals.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/advanced_examples/plot_5_multiple_truth_values/","title":"Multiple Truth Values","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/advanced_examples/plot_5_multiple_truth_values/#multiple-truth-values","title":"Multiple Truth Values","text":"<p>By default truth values are plotted with horizontal and vertical lines. However, if you have multiple truth values, this causes intersections which have no meaning.</p> <p>This can be alleviated visually by ensuring your different truth values are in different colours or line styles, but if you end up having numerous truth values, the grid of intersecting lines can still become an eyesore.</p> <p>See the below for an example.</p> <pre><code>from chainconsumer import Chain, ChainConsumer, Truth\n\ncols = [\"A\", \"B\"]\nchain1 = Chain.from_covariance([0.0, 0.0], [[1.0, -1], [-1, 2]], columns=cols, name=\"Contour 1\")\nchain2 = Chain.from_covariance([3.0, 3.0], [[1.0, 1], [1, 2]], columns=cols, name=\"Contour 2\")\nc = ChainConsumer()\nc.add_chain(chain1)\nc.add_chain(chain2)\nc.add_truth(Truth(location={\"A\": 0, \"B\": 0}, color=\"#fb7185\"))\nc.add_truth(Truth(location={\"A\": 3, \"B\": 3}, color=\"#1f2937\"))\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>To fix this, you have two options:</p> <ol> <li>Add markers instead of truth values.</li> <li>Tell the truth values to plot using a marker.</li> </ol> <p>To do option 2, simple pass in <code>marker</code> to the <code>Truth</code> object. This will ensure that your marginalised plots still have vertical lines at the truth values, while your contour plots will have markers.</p> <p>You also can pass in <code>marker_edge_width</code> and <code>marker_size</code> to control the appearance of the markers. Note though that matplotlib doesn't let you have marker edges for all markers, but if you try to increase the line width on a marker which doesn't support it, ChainConsumer will raise an error so you're not scratching your head over why the plots aren't changing!</p> <pre><code>c = ChainConsumer()\nc.add_chain(chain1)\nc.add_chain(chain2)\nc.add_truth(Truth(location={\"A\": 0, \"B\": 0}, color=\"#fb7185\", edge_color=\"#7a1a28\", marker=\"o\"))\nc.add_truth(Truth(location={\"A\": 3, \"B\": 3}, color=\"#1f2937\", marker=\"X\"))\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>The above example will give you points on the subplots showing 2D slices of the marginalised posterior, and vertical lines in the 1D marginalised histograms. If this makes the histograms too noisy and you only want to see the points in the contour plots, consider swapping over to simply putting in markers.</p> <p>I also apologise for the inconsistent naming here - marker becomes marker_style. Sorry.</p> <pre><code>c = ChainConsumer()\nc.add_chain(chain1)\nc.add_marker(\n    location={\"A\": 0, \"B\": 0},\n    name=\"Truth1\",\n    color=\"#fb7185\",\n    marker_style=\"o\",\n)\nc.add_marker(\n    location={\"A\": 3, \"B\": 3},\n    name=\"Truth2\",\n    color=\"#1f2937\",\n    marker_style=\"X\",\n)\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  2.375 seconds)</p> <p> Download Python source code: plot_5_multiple_truth_values.py</p> <p> Download Jupyter notebook: plot_5_multiple_truth_values.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"}]}